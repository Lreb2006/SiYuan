{"ID":"20250206195641-91d2wbg","Spec":"1","Type":"NodeDocument","Properties":{"id":"20250206195641-91d2wbg","title":"ACM板子总结","type":"doc","updated":"20250208192829"},"Children":[{"ID":"20250206195641-mkvwmue","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250206195641-mkvwmue","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# "},{"Type":"NodeText","Data":"ACM板子总结"}]},{"ID":"20250206195641-ns4xazn","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250206195641-ns4xazn","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## "},{"Type":"NodeText","Data":"\u003ccenter\u003e ACM"}]},{"ID":"20250206195641-vvpw1wc","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250206195641-vvpw1wc","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## "},{"Type":"NodeText","Data":"二分查找模板"}]},{"ID":"20250206195641-qsuztkl","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-qsuztkl","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"函数实现"}]},{"ID":"20250206195641-uaz8wjl","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-uaz8wjl","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\nusing namespace std;\n\n// 二分查找函数，查找目标值是否存在\nint bsearch(int *a, int n, int x) { // 数组a，长度n，目标值x\n    int l = 1, r = n;              // 左边界l，右边界r\n    while (l \u003c= r) {               // 循环直到左右边界重叠或越界\n        int m = (l + r) / 2;       // 中间位置m\n        if (a[m] == x) return m;   // 找到目标值返回下标\n        else if (a[m] \u003c x) l = m + 1; // 目标值在右区间\n        else r = m - 1;            // 目标值在左区间\n    }\n    return -1;                     // 未找到目标值返回-1\n}\n\nint main() {\n    int n = 6;                     // 数组长度\n    int a[] = {0, 2, 4, 6, 8, 10, 12}; // 数组，a[0]占位\n    int x = 8;                     // 要查找的目标值\n    int pos = bsearch(a, n, x);    // 调用二分查找函数\n    if (pos != -1) cout \u003c\u003c \"Found at: \" \u003c\u003c pos \u003c\u003c endl;\n    else cout \u003c\u003c \"Not found\" \u003c\u003c endl;\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-4wewftk","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-4wewftk","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"非函数实现"}]},{"ID":"20250206195641-6o100sg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-6o100sg","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\nusing namespace std;\n\nint main() {\n    int n = 6;                     // 数组长度\n    int a[] = {0, 2, 4, 6, 8, 10, 12}; // 数组，a[0]占位\n    int x = 8;                     // 要查找的目标值\n    int l = 1, r = n;              // 左边界l，右边界r\n    int pos = -1;                  // 存储目标值下标，默认-1表示未找到\n    while (l \u003c= r) {               // 循环直到左右边界重叠或越界\n        int m = (l + r) / 2;       // 中间位置m\n        if (a[m] == x) {           // 找到目标值\n            pos = m;               // 记录下标\n            break;                 // 退出循环\n        } else if (a[m] \u003c x) l = m + 1; // 目标值在右区间\n        else r = m - 1;            // 目标值在左区间\n    }\n    if (pos != -1) cout \u003c\u003c \"Found at: \" \u003c\u003c pos \u003c\u003c endl;\n    else cout \u003c\u003c \"Not found\" \u003c\u003c endl;\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-b7lvioo","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-b7lvioo","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"二分答案法经典题目实现形式"}]},{"ID":"20250206195641-frwul0k","Type":"NodeParagraph","Properties":{"id":"20250206195641-frwul0k","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"二分答案法的步骤："},{"Type":"NodeHardBreak","Data":"\n"},{"Type":"NodeText","Data":"确定搜索区间：根据题目要求，设定一个可能的答案范围。"},{"Type":"NodeHardBreak","Data":"\n"},{"Type":"NodeText","Data":"条件判断函数：定义一个函数 check(mid)，判断在当前值 mid 时，是否满足条件。"},{"Type":"NodeHardBreak","Data":"\n"},{"Type":"NodeText","Data":"二分查找：使用二分法在答案空间中查找满足条件的值。"},{"Type":"NodeHardBreak","Data":"\n"},{"Type":"NodeText","Data":"如果 check(mid) 返回 true，说明当前 mid 可能是一个可行解，尝试更大的值。"},{"Type":"NodeHardBreak","Data":"\n"},{"Type":"NodeText","Data":"如果 check(mid) 返回 false，说明当前 mid 不是可行解，尝试更小的值。"}]},{"ID":"20250206195641-y59la3q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-y59la3q","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003cbits/stdc++.h\u003e\nusing namespace std;\nint n;\nlong long c;\nconst int N = 2e5 + 10;\nint a[N];\nlong long check(int m){\n\tlong long s = 0;\n\tfor(int i = 1;i\u003c=n;i++){\n\t\ts += (a[i] + 2LL * m) * (a[i] + 2LL * m); \n\tif (s \u003e c) return s; \n\t}\n\treturn s;\n}\n\n\nint main() {\n\tcin\u003e\u003en\u003e\u003ec;\n\tfor(int i = 1;i\u003c=n;i++){\n\t\tcin\u003e\u003ea[i];\n\t}\n\n\tint l = 1, r = 1e6;          \n    int pos = -1;              \n    while (l \u003c= r) {           \n        int m = (l + r) / 2;\n\t\tlong long s  = check(m);  \n        if (s == c) {       \n            pos = m;\n            break;              \n        } else if (s \u003c c) l = m + 1; \n        else r = m - 1;        \n    }\n\ncout\u003c\u003cpos;\n\n\n\treturn 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-e6kmwjc","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-e6kmwjc","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"整数二分答案法模板（acwing）"}]},{"ID":"20250206195641-l5p6cff","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-l5p6cff","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"bool check(int x) {/* ... */} // 检查x是否满足某种性质\n\n// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：\n(满足性质的是右“半”边)\nint bsearch_1(int l, int r)\n{\n    while (l \u003c r)\n    {\n        int mid = l + r \u003e\u003e 1;\n        if (check(mid)) r = mid;    // check()判断mid是否满足性质\n        else l = mid + 1;\n    }\n    return l;\n}\n// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：\n(满足性质的是左“半”边)\nint bsearch_2(int l, int r)\n{\n    while (l \u003c r)\n    {\n        int mid = l + r + 1 \u003e\u003e 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-70jkui4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-70jkui4","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"浮点数二分答案法模板"}]},{"ID":"20250206195641-qryifkt","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3BwYm9vbA==","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-qryifkt","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3BwYm9vbA=="},{"Type":"NodeCodeBlockCode","Data":"double bsearch_3(double l, double r)\n{\n    const double eps = 1e-6;   // eps 表示精度，取决于题目对精度的要求(1e-的这个数要比要求的有效位数大2)\n    while (r - l \u003e eps)\n    {\n        double mid = (l + r) / 2;\n        if (check(mid)) r = mid;\n        else l = mid;\n    }\n    return l;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-zh9foaj","Type":"NodeParagraph","Properties":{"id":"20250206195641-zh9foaj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"‍"}]},{"ID":"20250206195641-ox6e0y1","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250206195641-ox6e0y1","updated":"20250208192829"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## "},{"Type":"NodeText","Data":"一维前缀和模板"}]},{"ID":"20250206195641-ilg38np","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250206195641-ilg38np","updated":"20250208192829"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"\n#include\u003cbits/stdc++.h\u003e\nusing namespace std;\n\nconst int N = 1e5 + 10;\nint sum[N],a[N];\nint n,m;\nint  l,r;\n\nint main() {\n\n\tcin\u003e\u003en\u003e\u003em;  //n为数组a的长度，m为询问次数\n\n\tfor(int i = 1;i\u003c=n;i++){\n\t\tcin\u003e\u003ea[i];\n\t\tsum[i] = sum[i-1] + a[i];\n\t}\n\tfor(int i = 1;i\u003c=m;i++){\n\t\tcin\u003e\u003el\u003e\u003er;   //左区间和右区间\n\t\tcout\u003c\u003csum[r] - sum[l-1]\u003c\u003cendl; //区间[l, r]内元素的和,非下标\n\t}\n\n\treturn 0;\n}\n\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250206195641-2f4rf10","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250206195641-2f4rf10","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## "},{"Type":"NodeText","Data":"一维差分处理区间增量问题"}]},{"ID":"20250206195641-l2egjbf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-l2egjbf","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e \nusing namespace std;\n\nint main() {\n    const int N = 1e5 + 10;     //N表示数组的最大长度\n    int a[N] = {0}, b[N] = {0};\n    int n, m;                   //n为数组a的长度，m为询问次数\n    cin \u003e\u003e n \u003e\u003e m;\n    for (int i = 1; i \u003c= n; i++) {\n        cin \u003e\u003e a[i];            \n        b[i] = a[i] - a[i - 1]; // 构建差分数组b\n    }\n\n    while (m--) {\n        int l, r, c;            // l 和 r 表示操作的区间 [l, r]，c 表示加的值\n        cin \u003e\u003e l \u003e\u003e r \u003e\u003e c; \n        b[l] += c;\n        if (r + 1 \u003c= n) {       // 如果 r+1 没有越界\n            b[r + 1] -= c;\n        }\n    }\n    // 根据差分数组 b 计算最终的数组a\n    for (int i = 1; i \u003c= n; i++) {\n        a[i] = a[i - 1] + b[i]; // 根据前缀和恢复原数组a\n    }\n    \n    for (int i = 1; i \u003c= n; i++) {\n        cout \u003c\u003c a[i] \u003c\u003c \" \"; \n    }\n    cout \u003c\u003c endl;\n    return 0; \n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-0iz9cw1","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250206195641-0iz9cw1","updated":"20250208184020"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## "},{"Type":"NodeText","Data":"二维前缀和模板"}]},{"ID":"20250206195641-zp5nf0t","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"Properties":{"id":"20250206195641-zp5nf0t","updated":"20250208184020"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```"},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"\n#include\u003cbits/stdc++.h\u003e\nusing namespace std;\n\nconst int N = 1e9+100;\nint s[N][N],a[N][N];\nint x,y,w;\nint main() {\n\n\tint n,m,q;\n\tcin\u003e\u003en\u003e\u003em\u003e\u003eq;\n\n\tfor(int i = 1;i\u003c=n;i++){\n\t\tfor(int j =1;j\u003c=m;j++){\n\t\t\tcin\u003e\u003ea[i][j];\n\t\t\t//sij包含了从矩阵左上角(1,1)位置到(i,j)位置形成的矩形区域内的所有元素之和\n\t\t\ts[i][j] = s[i-1][j]+ s[i][j-1]+a[i][j] - s[i-1][j-1];\n\t\t}\n\t}\n\t\n\tint x1,y1,x2,y2;\n\tfor(int i = 1;i\u003c=q;i++){\n\t\tcin\u003e\u003ex1\u003e\u003ey1\u003e\u003ex2\u003e\u003ey2;\n\t\tcout\u003c\u003cs[x2][y2] - s[x1-1][y2] - s[x2][y1-1] + s[x1-1][y1-1]\u003c\u003cendl; //求从x1,y1到x2,y2的区域和\n\t}\n\n\treturn 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```"}]},{"ID":"20250206195641-inw9o45","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250206195641-inw9o45","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## "},{"Type":"NodeText","Data":"二维差分增量模板"}]},{"ID":"20250206195641-zs6x95h","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-zs6x95h","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003cbits/stdc++.h\u003e\nusing namespace std;\n\nconst int N = 1000 + 10;\nint a[N][N], b[N][N];\nint n, m, q;\n\nvoid insert(int x1, int y1, int x2, int y2, int c) {     \n    b[x1][y1] += c;\n    b[x2 + 1][y1] -= c;\n    b[x1][y2 + 1] -= c;\n    b[x2 + 1][y2 + 1] += c;\n}\n\nint main() {\n    cin \u003e\u003e n \u003e\u003e m \u003e\u003e q;\n    for (int i = 1; i \u003c= n; i++) {\n        for (int j = 1; j \u003c= m; j++) {\n            cin \u003e\u003e a[i][j];\n            b[i][j] = a[i][j] - a[i-1][j] - a[i][j-1] + a[i-1][j-1];\n        }\n    }\n    while (q--) {\n        int x1, y1, x2, y2, c;\n        cin \u003e\u003e x1 \u003e\u003e y1 \u003e\u003e x2 \u003e\u003e y2 \u003e\u003e c;\n        insert(x1, y1, x2, y2, c);\n    }\n    for (int i = 1; i \u003c= n; i++) {\n        for (int j = 1; j \u003c= m; j++) {\n            a[i][j] = b[i][j] + a[i-1][j] + a[i][j-1] - a[i-1][j-1];\n            cout \u003c\u003c a[i][j] \u003c\u003c \" \";\n        }\n        cout \u003c\u003c endl;\n    }\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-7qabnwl","Type":"NodeHeading","HeadingLevel":2,"Properties":{"id":"20250206195641-7qabnwl","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"## "},{"Type":"NodeText","Data":"其他常用代码片段"}]},{"ID":"20250206195641-ka3mfsr","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-ka3mfsr","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"遍历所有排列情况"}]},{"ID":"20250206195641-0cxu3j7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-0cxu3j7","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"do {   } while (next_permutation(v.begin(), v.end()));\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-svsasfi","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-svsasfi","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"清理缓存区"}]},{"ID":"20250206195641-islapwk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-islapwk","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"cin.ignore(numeric_limits\u003cstreamsize\u003e::max(), '\\n');\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-4ii943m","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-4ii943m","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"经典队列操作应用题目"}]},{"ID":"20250206195641-0iu1t7n","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-0iu1t7n","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003cbits/stdc++.h\u003e\nusing namespace std;\n\nint main() {\n    int m, n;           //m表示缓存最大容量，n表示询问次数\n    cin \u003e\u003e m \u003e\u003e n;      // 读取缓存容量 m 和页面访问次数 n\n    deque\u003cint\u003e q(m);  // 创建一个大小为 m 的双端队列，用来模拟缓存，默认大小为 m\n    int a;  // 用来存储当前访问的页面\n    int cnt = 0;  // 用来记录页面缺失的次数\n    int qq[1010] = {0};  // 定义一个数组 qq，长度为 1010，初始化所有元素为 0，用来记录哪些页面在缓存中\n    for (int i = 1; i \u003c= n; i++) {  // 遍历所有页面访问\n        cin \u003e\u003e a;  // 读取当前访问的页面号\n        if (!qq[a]) {  // 如果页面 a 不在缓存中\n            cnt++;  // 页面缺失，增加缺页次数\n            if (q.size() == m) {  // 如果缓存已满\n                int x = q.front();  // 获取队列的第一个元素，即最久未使用的页面\n                q.pop_front();  // 从队列中移除最久未使用的页面\n                qq[x] = 0;  // 更新数组 qq，标记页面 x 不在缓存中\n            }\n            q.push_back(a);  // 将当前页面 a 加入队列（缓存）\n            qq[a] = 1;  // 更新数组 qq，标记页面 a 已经在缓存中\n        }\n    }\n    cout \u003c\u003c cnt;  // 输出缺页次数\n    return 0;  // 程序结束\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-mxk977a","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-mxk977a","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"字符串输入"}]},{"ID":"20250206195641-p7p7dr2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-p7p7dr2","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"string arr[100];\ngetline(cin, arr[i]);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-qc7jn6p","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-qc7jn6p","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"自定义排序函数"}]},{"ID":"20250206195641-38t444a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-38t444a","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"bool cmp(类型 a, 类型 b) {\n    // 第一条件: 比较 a 和 b\n    if (条件1) {\n        return 排序规则1;\n    }\n    // 第二条件: 如果第一条件不满足，比较 a 和 b\n    if (条件2) {\n        return 排序规则2;\n    }\n    // 第三条件: 如果前面所有条件都不满足，继续比较\n    if (条件3) {\n        return 排序规则3;\n    }\n    // 默认返回\n    return 排序规则默认;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-v1cwena","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-v1cwena","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"循环数组索引更新"}]},{"ID":"20250206195641-scnxif1","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-scnxif1","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"index = (index + 1) % n; // 因为是循环，使用%运算确保数组循环\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-9gasyjn","Type":"NodeBlockquote","Properties":{"id":"20250206195641-9gasyjn","updated":"20250206195641"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e "},{"ID":"20250206195641-cxpcxhy","Type":"NodeParagraph","Properties":{"id":"20250206195641-cxpcxhy","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"解释："},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"这段代码的含义是在一个固定大小为 n 的数组中循环更新 index，确保它始终保持在合法范围内（0 到 n-1）。它通过取模运算（%）实现循环行为。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"具体分析："},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"1.index + 1:"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"将当前索引值 index 增加 1，表示向后移动一个位置。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"2.% n:"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"模运算确保索引不会超出数组的边界。如果增加后索引等于或大于 n，模运算会使它“回到”开头。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"例如："},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"2.1 如果 index + 1 = n，则 (index + 1) % n = 0。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"2.2 如果 index + 1 = n + 1，则 (index + 1) % n = 1。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"3.循环效果:"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"模运算的结果总是一个小于 n 的非负数，这样可以实现数组的循环访问。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"3.1 当 index 为数组最后一个位置（n-1）时，执行 (index + 1) % n 会将索引跳转到第一个位置 0。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"3.2 否则，索引会正常向后移动。"}]}]},{"ID":"20250206195641-pmpg7do","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-pmpg7do","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"注意做题时样例输入陷阱，特殊样例，比如数组长度为0，尤其注意题目给的范围，比如＞＝"}]},{"ID":"20250206195641-cr04xeo","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-cr04xeo","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"格式化输出"}]},{"ID":"20250206195641-np79qxa","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-np79qxa","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"cout \u003c\u003c setfill('0') \u003c\u003c setw(2) \u003c\u003c sum;\ncout \u003c\u003c fixed \u003c\u003c setprecision(2) \u003c\u003c num \u003c\u003c endl;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-igdwrga","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-igdwrga","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"输出32位二进制形式"}]},{"ID":"20250206195641-afxq3fk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-afxq3fk","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"cout \u003c\u003c bitset\u003c32\u003e(n) \u003c\u003c endl;\ncin \u003e\u003e oct \u003e\u003e n; // 从输入以八进制形式读取一个整数\ncout \u003c\u003c dec \u003c\u003c n; // 以十进制形式输出该整数\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-yqns4hn","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-yqns4hn","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"sawp函数不要忘了使用"}]},{"ID":"20250206195641-traegr2","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-traegr2","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"注意样例空格"}]},{"ID":"20250206195641-7r24u0j","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-7r24u0j","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"字符串和整数转换"}]},{"ID":"20250206195641-dq9abv7","Type":"NodeBlockquote","Properties":{"id":"20250206195641-dq9abv7","updated":"20250206195641"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e "},{"ID":"20250206195641-iyt3ixe","Type":"NodeParagraph","Properties":{"id":"20250206195641-iyt3ixe","updated":"20250206195641"},"Children":[{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeLinkText","Data":"Example Image"},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"./image.png"},{"Type":"NodeCloseParen","Data":")"}]}]},{"ID":"20250206195641-kpsztxa","Type":"NodeParagraph","Properties":{"id":"20250206195641-kpsztxa","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"以字符串的形式输入数组进行数字的运算时，字符’0’实际上是48"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"注意在C++中，字符和整数之间可以进行转换。字符'0'到'9'的ASCII码分别是48到57。当你从一个字符中减去'0'时，实际上是将该字符转换为对应的数字。"}]}]},{"ID":"20250206195641-37gxkqg","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-37gxkqg","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"注意int long范围，数组可能是double类型等等"}]},{"ID":"20250206195641-pgh6ewj","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-pgh6ewj","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"字符数组长度"}]},{"ID":"20250206195641-ampape7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-ampape7","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"char a[100];\nint b = strlen(a);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-o3t3u5z","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-o3t3u5z","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"字符串长度"}]},{"ID":"20250206195641-e16yvjm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-e16yvjm","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"string a;\nint b = a.size();\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-1y2zuhw","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-1y2zuhw","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"宏定义"}]},{"ID":"20250206195641-0l6ft5a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-0l6ft5a","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#define 宏名 替换内容\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-hx7dlz9","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-hx7dlz9","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"定义尽量都在主函数外定义"}]},{"ID":"20250206195641-gtipl9p","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-gtipl9p","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"类型别名"}]},{"ID":"20250206195641-l5uzxok","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-l5uzxok","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"using ll = long long;\n\ntypedef long long ll;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-hykznol","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-hykznol","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"结构体数组示例（贪心排序题可能用到）"}]},{"ID":"20250206195641-m3mamlu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-m3mamlu","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003calgorithm\u003e // 包含 sort 函数\nusing namespace std;\n\nstruct Point {\n    int x, y;\n};\n\n// 自定义比较函数\nbool cmp(const Point \u0026a, const Point \u0026b) {\n    if (a.x == b.x) {\n        return a.y \u003c b.y;  // 如果 x 相同，按 y 排序\n    }\n    return a.x \u003c b.x;  // 否则按 x 排序\n}\n\nint main() {\n    Point points[3];\n    // 通过 cin 输入结构体数组\n    for (int i = 0; i \u003c 3; i++) {\n        cin \u003e\u003e points[i].x \u003e\u003e points[i].y;\n    }\n    // 使用自定义比较函数进行排序\n    sort(points, points + 3, cmp);\n    // 输出排序后的数组\n    for (int i = 0; i \u003c 3; ++i) {\n        cout \u003c\u003c \"points[\" \u003c\u003c i \u003c\u003c \"]: x=\" \u003c\u003c points[i].x \u003c\u003c \", y=\" \u003c\u003c points[i].y \u003c\u003c endl;\n    }\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-at2ji2y","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-at2ji2y","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"lower_bound"},{"Type":"NodeText","Data":" 和 "},{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"upper_bound"}]},{"ID":"20250206195641-qwfqmb7","Type":"NodeBlockquote","Properties":{"id":"20250206195641-qwfqmb7","updated":"20250206195641"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e "},{"ID":"20250206195641-f7wxjbw","Type":"NodeParagraph","Properties":{"id":"20250206195641-f7wxjbw","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"lower_bound 是 C++ 标准库 \u003calgorithm\u003e 中的一个非常有用的函数，它用于在已排序的容器中查找第一个不小于（即大于或等于）给定值的元素的位置。它可以用于数组、vector、deque、set 和 map 等支持随机访问或二叉搜索的数据结构。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"（容器中的元素必须是已排序的。lower_bound 使用二分查找，因此只有在排序容器中才能正确工作。）"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"auto 是 C++11 引入的一个关键字，用于自动推导变量的类型。通过使用 auto，编译器可以根据变量初始化时的值自动推导出该变量的类型。这使得代码更加简洁，特别是在处理复杂的类型时（例如迭代器或类型较长的容器元素）。"}]}]},{"ID":"20250206195641-1fd9rrc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-1fd9rrc","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003calgorithm\u003e\nusing namespace std;\n\nvector\u003cint\u003e vec = {1, 3, 3, 5, 7, 9};\n// 查找第一个不小于 3 的位置（即第一个 3）\nauto lb = lower_bound(vec.begin(), vec.end(), 3);\n// 查找第一个大于 3 的位置（即第一个大于 3 的元素位置）\nauto ub = upper_bound(vec.begin(), vec.end(), 3);\n//lb 的位置是 vec.begin() + 1，即指向第一个 3。\n//ub 的位置是 vec.begin() + 3，即指向第一个大于 3 的元素 5。\ncout \u003c\u003c \"lb: \" \u003c\u003c (lb - vec.begin()) \u003c\u003c endl;  // 输出 1，表示第一个 3\ncout \u003c\u003c \"ub: \" \u003c\u003c (ub - vec.begin()) \u003c\u003c endl;  // 输出 3，表示 5\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-acit6qd","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-acit6qd","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nconst int N = 1e5 + 10;\n\nlong long a[N], b[N];\n\nint main() {\n    int n, m, sum;\n    cin \u003e\u003e n \u003e\u003e m \u003e\u003e sum;\n    \n    // 输入数组 a[] 和 b[]\n    for (int i = 0; i \u003c n; i++) {\n        cin \u003e\u003e a[i];\n    }\n    for (int i = 0; i \u003c m; i++) {\n        cin \u003e\u003e b[i];\n    }\n\n    // 对数组 b[] 进行排序\n    sort(b, b + m);\n\n    // 遍历数组 a[]，对于每个 a[i] 使用二分查找\n    for (int i = 0; i \u003c n; i++) {\n        long long target = sum - a[i];\n        // 在 b[] 中查找 target\n        int idx = lower_bound(b, b + m, target) - b;\n\n        // 检查是否找到并且满足 a[i] + b[idx] == sum\n        if (idx \u003c m \u0026\u0026 b[idx] == target) {\n            cout \u003c\u003c i \u003c\u003c \" \" \u003c\u003c idx \u003c\u003c endl;\n            return 0;  // 找到后直接退出\n        }\n    }\n\n    // 如果没有找到符合条件的 pair\n    cout \u003c\u003c -1 \u003c\u003c endl;\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-2jequmw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-2jequmw","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"STL 常用函数"}]},{"ID":"20250206195641-j6bs8er","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-j6bs8er","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"最值"}]},{"ID":"20250206195641-1kxom4i","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-1kxom4i","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"max(x, y);  // 返回 x 和 y 较大值\nmin(x, y);  // 返回 x 和 y 较小值\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-fv3lbgk","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-fv3lbgk","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"排序"}]},{"ID":"20250206195641-i1wyxo2","Type":"NodeParagraph","Properties":{"id":"20250206195641-i1wyxo2","updated":"20250206195641"},"Children":[{"Type":"NodeTextMark","TextMarkType":"code","TextMarkTextContent":"sort(va.begin(), va.end(), cmp);"}]},{"ID":"20250206195641-kkfkl24","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-kkfkl24","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"子串操作"}]},{"ID":"20250206195641-kmaywcm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-kmaywcm","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"\n#include \u003ciostream\u003e\n#include \u003ccstring\u003e // 包含 C 字符串处理函数 strstr\nusing namespace std;\n\nint main() {\n    //子串截取\n    string s = \"Hello, World!\";\n    string sub = s.substr(7, 5);    // 从下标 7 开始截取 5 个字符\n    s.erase(7, 10);                 // 从下标7 删除 10 个字符\n\n    //查找子串\n    size_t pos = s.find(\"World\");   // 查找 \"World\" 的位置，一般返回第一个字母起始下标\n    if (pos != string::npos) {\n    cout \u003c\u003c \"Found at: \" \u003c\u003c pos \u003c\u003c endl; // 如果找到，输出位置\n    }\n\n    // 定义两个字符数组，用于存储输入的源字符串和需要查找的子串\n    char str[100];                  // 源字符串\n    char target[100];               // 子串\n    cin.getline(str, 100);          // 使用 getline 读取一整行字符串\n    cin.getline(target, 100);       // 输入需要查找的子串\n    const char* pos = strstr(str, target);  // 使用 strstr 函数查找子串在源字符串中的位置\n     // 判断是否找到子串\n    if (pos != nullptr) {\n        // 如果找到，计算子串的起始下标，并输出\n        cout \u003c\u003c \"Substring found at index: \" \u003c\u003c (pos - str) \u003c\u003c endl;  \n    } else {\n        cout \u003c\u003c \"Substring not found!\" \u003c\u003c endl;  \n    }\n    return 0; \n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-k6nejtm","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-k6nejtm","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"双指针模板"}]},{"ID":"20250206195641-q8nunfa","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-q8nunfa","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003calgorithm\u003e\nusing namespace std;\n\nint main() {\n    int n, x;           // n为数组大小，x为目标和\n    cin \u003e\u003e n \u003e\u003e x;      // 输入n和目标和x\n    int a[n + 1];       // 数组，从1开始存储\n    for (int i = 1; i \u003c= n; i++) {\n        cin \u003e\u003e a[i];    // 输入数组\n    }\n    sort(a + 1, a + n + 1); // 排序数组\n    int i = 1, j = n;   // 双指针初始化\n    while (i \u003c j) {\n        int s = a[i] + a[j]; // 当前两个数的和\n        if (s == x) {\n            cout \u003c\u003c a[i] \u003c\u003c \" \" \u003c\u003c a[j] \u003c\u003c endl;\n            break;\n        } else if (s \u003c x) {\n            i++;        // 左指针右移\n        } else {\n            j--;        // 右指针左移\n        }\n    }\n    if (i \u003e= j) {\n        cout \u003c\u003c \"No solution\" \u003c\u003c endl; // 没有找到满足条件的数对\n    }\n    return 0;\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-nrru70x","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-nrru70x","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"1.7.0输出单词"}]},{"ID":"20250206195641-2itlxvp","Type":"NodeParagraph","Properties":{"id":"20250206195641-2itlxvp","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"给定一行句子，输出其中的单词"}]},{"ID":"20250206195641-okvpr3t","Type":"NodeBlockquote","Properties":{"id":"20250206195641-okvpr3t","updated":"20250206195641"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e "},{"ID":"20250206195641-r0ybtix","Type":"NodeParagraph","Properties":{"id":"20250206195641-r0ybtix","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"样例输入"}]},{"ID":"20250206195641-tbwp7u6","Type":"NodeParagraph","Properties":{"id":"20250206195641-tbwp7u6","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"i am student"}]}]},{"ID":"20250206195641-fzdg2sk","Type":"NodeBlockquote","Properties":{"id":"20250206195641-fzdg2sk","updated":"20250206195641"},"Children":[{"Type":"NodeBlockquoteMarker","Data":"\u003e "},{"ID":"20250206195641-5cpa9lq","Type":"NodeParagraph","Properties":{"id":"20250206195641-5cpa9lq","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"样例输出"}]},{"ID":"20250206195641-i1yxrp1","Type":"NodeParagraph","Properties":{"id":"20250206195641-i1yxrp1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"i"}]},{"ID":"20250206195641-vb0j2bd","Type":"NodeParagraph","Properties":{"id":"20250206195641-vb0j2bd","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"am"}]},{"ID":"20250206195641-3ab8nzo","Type":"NodeParagraph","Properties":{"id":"20250206195641-3ab8nzo","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"student"}]}]},{"ID":"20250206195641-zhxt9of","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-zhxt9of","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003cbits/stdc++.h\u003e\n#include \u003cstring\u003e\nusing namespace std;\n\nint main()\n{\n    char str[1000];\n    // 使用 gets() 读取一行字符串（注意：gets() 已被弃用，推荐使用 fgets() 或 getline()）\n    gets(str);\n  \n    // 获取字符串的长度\n    int n = strlen(str);\n  \n    // 遍历字符串，逐个输出单词\n    for (int i = 0; i \u003c n; i++)\n    {\n        int j = i;\n        // 指针 j 扫描字符串，直到遇到空格或者字符串结束\n        while (j \u003c n \u0026\u0026 str[j] != ' ') \n            j++; // j 指向当前单词结束的位置（空格处或者字符串末尾）\n      \n        // 输出当前单词（从 i 到 j-1）\n        for (int k = i; k \u003c j; k++) \n            cout \u003c\u003c str[k];\n        cout \u003c\u003c endl; // 输出换行符，每个单词单独占一行\n      \n        // 将 i 移动到 j 处，即空格后的第一个字符位置\n        // 注意：这里 i 在 for 循环的自增中会自动 +1，因此如果想跳过空格，\n        // 可能需要额外处理多个连续空格的情况（当前代码假设单词间仅有一个空格）\n        i = j;\n    }\n    return 0;\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-9ri3u9o","Type":"NodeParagraph","Properties":{"id":"20250206195641-9ri3u9o","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"‍"}]},{"ID":"20250206195641-mbljdbs","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-mbljdbs","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"注意事项补充"}]},{"ID":"20250206195641-xvh2db2","Type":"NodeParagraph","Properties":{"id":"20250206195641-xvh2db2","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"不要忘了把oj的编译模式换成C++"}]},{"ID":"20250206195641-l399gs2","Type":"NodeParagraph","Properties":{"id":"20250206195641-l399gs2","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"一定注意输入的是n的范围还是n个整数的范围！！！！"}]},{"ID":"20250206195641-ar8lhzo","Type":"NodeParagraph","Properties":{"id":"20250206195641-ar8lhzo","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"注意输入样例形式，如1111与1 1 1 1你就要考虑不同的接收输入的方式了"}]},{"ID":"20250206195641-u2fc6z2","Type":"NodeParagraph","Properties":{"id":"20250206195641-u2fc6z2","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"别把2*i写成2i"}]},{"ID":"20250206195641-j3bx6vg","Type":"NodeParagraph","Properties":{"id":"20250206195641-j3bx6vg","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"为防止爆long long ,需对等式右边进行强转"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"如:s += (a[i] + 2LL * m) * (a[i] + 2LL * m);"}]},{"ID":"20250206195641-spsy0jt","Type":"NodeParagraph","Properties":{"id":"20250206195641-spsy0jt","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"定义cmp时,不要带等号"}]},{"ID":"20250206195641-bne9nb8","Type":"NodeParagraph","Properties":{"id":"20250206195641-bne9nb8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"使用auto遍历容器时,要改变容器内元素加\u0026,不改变不加."}]},{"ID":"20250206195641-kizjc35","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-kizjc35","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"continue用法示例"}]},{"ID":"20250206195641-gljy2d2","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-gljy2d2","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"//数字反转,消除原数末尾0,但中间0不动.\nint flag = 1;\nfor(int i = p-1;i\u003e=0;i--){\n    if(a[i]=='0' \u0026\u0026 flag==1 \u0026\u0026 i\u003e0){\n        continue;\n    }\n    flag = 0;\n    cout\u003c\u003ca[i];\n\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-cyx9fff","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-cyx9fff","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"字符串经典操作例题(包含回文,去重,取子串)"}]},{"ID":"20250206195641-caml9lc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-caml9lc","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003cbits/stdc++.h\u003e\nusing namespace std;\nstring s;\nstring zican(string sub){\n\tstring a = \"\";\n\ta+=sub[0];\n\t\n\tfor(int i = 0;i\u003csub.size()-1;i++){\n\t\tif(sub[i+1]!=sub[i]){\n\t\t\ta += sub[i+1];\n\t\t}\n\t}\n\treturn a;\n\t\n}\nbool huiwen(string subb){\n\tint i = 0;\n\tint j = subb.size()-1;\n\twhile(i\u003c=j){\n\t\tif(subb[i]!=subb[j]){\n\t\t\treturn false;\n\t\t}\n\t\ti++;\n\t\tj--;\n\t}\n\treturn true;\n}\n\nint main() {\n\tlong long sumj = 0;\n\tlong long sumo = 0;\n\tcin\u003e\u003es;\n\tint n = s.size();\n\tfor(int i = 0;i\u003cn;i++){\n\t\tfor(int j = 1;i+j\u003c=n;j++){\n\t\t\tstring sub = s.substr(i,j);\n\t\t\tstring subb = zican(sub);\n\t\t\tif(huiwen(subb)){\n\t\t\t\tif(j%2==0){\n\t\t\t\t\tsumo++;\n\t\t\t\t}else{\n\t\t\t\t\tsumj++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout\u003c\u003csumo\u003c\u003c\" \"\u003c\u003csumj;\n\t\n\treturn 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-ce7yg2s","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-ce7yg2s","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"C风格字符串处理"}]},{"ID":"20250206195641-yh8a285","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20250206195641-yh8a285","updated":"20250206195641"},"Children":[{"ID":"20250206195641-q2aqb6b","Type":"NodeListItem","Data":"1","ListData":{"Typ":1,"Tight":true,"Start":1,"Delimiter":46,"Padding":3,"Marker":"MQ==","Num":1},"Properties":{"id":"20250206195641-q2aqb6b","updated":"20250206195641"},"Children":[{"ID":"20250206195641-bc2mrk8","Type":"NodeParagraph","Properties":{"id":"20250206195641-bc2mrk8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"int result = strcmp(str1, str2);"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"strcmp 用于比较两个 C 风格字符串（即 char 数组）"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"返回 0：如果两个字符串相等。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"返回一个负整数：如果 str1 小于 str2（按字典顺序比较）。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"返回一个正整数：如果 str1 大于 str2（按字典顺序比较）."}]}]},{"ID":"20250206195641-78s26zh","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20250206195641-78s26zh","updated":"20250206195641"},"Children":[{"ID":"20250206195641-4unld2m","Type":"NodeParagraph","Properties":{"id":"20250206195641-4unld2m","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"strcpy 用于将一个 C 风格字符串的内容复制到另一个字符串中."},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"char* strcpy(char* dest, const char* src);"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"dest：目标字符数组，拷贝的结果会存储在这里。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"src：源字符数组，即你要复制的字符串。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"返回值：返回目标字符串 dest 的指针。"}]}]},{"ID":"20250206195641-np4szdl","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20250206195641-np4szdl","updated":"20250206195641"},"Children":[{"ID":"20250206195641-8meez37","Type":"NodeParagraph","Properties":{"id":"20250206195641-8meez37","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"strcat 用于将一个字符串连接到另一个字符串的末尾。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"char* strcat(char* dest, const char* src);"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"dest：目标字符数组，连接结果将存储在此。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"src：源字符数组，要追加的字符串。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"返回值：返回目标字符串 dest 的指针。"}]}]},{"ID":"20250206195641-we3emdc","Type":"NodeListItem","Data":"4","ListData":{"Typ":1,"Tight":true,"Start":4,"Delimiter":46,"Padding":3,"Marker":"NA==","Num":4},"Properties":{"id":"20250206195641-we3emdc","updated":"20250206195641"},"Children":[{"ID":"20250206195641-hbiwmli","Type":"NodeParagraph","Properties":{"id":"20250206195641-hbiwmli","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"strchr 用于查找字符串中第一次出现指定字符的位置。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"str：要查找的字符串。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"ch：要查找的字符。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"返回值：返回指向找到的字符的指针，如果没有找到，则返回 nullptr。"}]}]}]},{"ID":"20250206195641-fobt51j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-fobt51j","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003ccstring\u003e\nusing namespace std;\n\nint main() {\n    const char* str = \"Hello, world!\";\n    char* pos = strchr(str, 'o');  // 查找字符 'o'\n\n    if (pos != nullptr) {\n        cout \u003c\u003c \"Found 'o' at position: \" \u003c\u003c (pos - str) \u003c\u003c endl;  // 计算相对位置\n    } else {\n        cout \u003c\u003c \"'o' not found!\" \u003c\u003c endl;\n    }\n\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-1286xcl","Type":"NodeParagraph","Properties":{"id":"20250206195641-1286xcl","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出:Found 'o' at position: 4"}]},{"ID":"20250206195641-eywhei5","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20250206195641-eywhei5","updated":"20250206195641"},"Children":[{"ID":"20250206195641-8rw3gso","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20250206195641-8rw3gso","updated":"20250206195641"},"Children":[{"ID":"20250206195641-9plgbo8","Type":"NodeParagraph","Properties":{"id":"20250206195641-9plgbo8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"strtok 用于分割字符串，它根据指定的分隔符把一个字符串分解为多个子字符串。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"char* strtok(char* str, const char* delimiters);"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"str：待分割的字符串。首次调用时需要传入原始字符串，后续调用可以传入 nullptr 来继续分割。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"delimiters：用于分割的分隔符（多个字符）。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"返回值：返回指向子字符串的指针。"}]}]}]},{"ID":"20250206195641-es7ghu6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-es7ghu6","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003ccstring\u003e\nusing namespace std;\n\nint main() {\n    char str[] = \"Hello, world, C++!\";\n    char* token = strtok(str, \", \");  // 以 \", \" 作为分隔符\n\n    while (token != nullptr) {\n        cout \u003c\u003c \"Token: \" \u003c\u003c token \u003c\u003c endl;\n        token = strtok(nullptr, \", \");  // 继续分割\n    }\n\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-ax4fp1d","Type":"NodeParagraph","Properties":{"id":"20250206195641-ax4fp1d","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出:Token: Hello"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"Token: world"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"Token: C++"}]},{"ID":"20250206195641-9cvmkwx","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20250206195641-9cvmkwx","updated":"20250206195641"},"Children":[{"ID":"20250206195641-1zw8ayv","Type":"NodeListItem","Data":"6","ListData":{"Typ":1,"Tight":true,"Start":6,"Delimiter":46,"Padding":3,"Marker":"Ng==","Num":6},"Properties":{"id":"20250206195641-1zw8ayv","updated":"20250206195641"},"Children":[{"ID":"20250206195641-98zmfqo","Type":"NodeParagraph","Properties":{"id":"20250206195641-98zmfqo","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"strncat 类似于 strcat，但它会限制连接的字符数量，防止溢出"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"dest：目标字符数组。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"src：源字符串。"},{"Type":"NodeSoftBreak","Data":"\n"},{"Type":"NodeText","Data":"n：要连接的最大字符数。"}]}]}]},{"ID":"20250206195641-to6si2y","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-to6si2y","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"快速幂算法"}]},{"ID":"20250206195641-onz496y","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-onz496y","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\nusing namespace std;\n\n// 快速幂函数：计算 a^b\nint qp(int a, int b) {\n    int r = 1;         // r 存储结果，初始为 1\n    while (b \u003e 0) {    // 当指数 b 大于 0 时继续循环\n        if (b % 2)     // 如果 b 是奇数\n            r *= a;    // 将当前基数累乘到结果\n        a *= a;        // 基数自乘\n        b /= 2;        // 指数减半\n    }\n    return r;          // 返回计算结果\n}\n\nint main() {\n    int a, b;\n    cout \u003c\u003c \"输入底数和指数：\";\n    cin \u003e\u003e a \u003e\u003e b;              // 输入底数 a 和指数 b\n    cout \u003c\u003c a \u003c\u003c \"^\" \u003c\u003c b \u003c\u003c \" = \" \u003c\u003c qp(a, b) \u003c\u003c endl;\n    return 0;\n}\n\n\n\n------------------------------------------------------------------------------\n\n#include \u003ciostream\u003e\n#include \u003ccstring\u003e\n#include \u003calgorithm\u003e\n#include \u003ccstdio\u003e\nusing namespace std;\n\n// 定义长整型别名，便于后续使用\ntypedef long long LL;\n\n// 快速幂函数，计算 (a^k) % p\nint qmi(int a, int k, int p)\n{\n    int res = 1; // 初始化结果为 1\n    while (k) // 当指数 k 不为 0 时循环\n    {\n        if (k \u0026 1) // 如果 k 是奇数，累乘当前的 a 并取模\n            res = (LL)res * a % p;\n        k /= 2; // 指数 k 右移一位，相当于整除 2\n        a = (LL)a * a % p; // 底数自乘并取模\n    }\n    return res; // 返回计算结果\n}\n\nint main()\n{\n    int n;\n    cin \u003e\u003e n; // 读取测试用例数量\n    while (n--) // 循环处理每个测试用例\n    {\n        int a, k, p;\n        cin \u003e\u003e a \u003e\u003e k \u003e\u003e p; // 读取底数 a，指数 k 和模数 p\n        cout \u003c\u003c qmi(a, k, p) \u003c\u003c endl; // 输出快速幂结果\n    }\n    return 0;\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-koir8oj","Type":"NodeParagraph","Properties":{"id":"20250206195641-koir8oj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"‍"}]},{"ID":"20250206195641-py9pubk","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-py9pubk","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"快速幂"}]},{"ID":"20250206195641-4tzig2c","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-4tzig2c","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"4.4.1快速幂"}]},{"ID":"20250206195641-ez1gekr","Type":"NodeParagraph","Properties":{"id":"20250206195641-ez1gekr","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/c43dce09485420a03ad2f4faa4f566d2.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-pxf7osm","Type":"NodeParagraph","Properties":{"id":"20250206195641-pxf7osm","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/8b5f523e7d6d170db8c10dfc0b8efc3b.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-cm8375o","Type":"NodeParagraph","Properties":{"id":"20250206195641-cm8375o","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"时间复杂度为O(log n)"}]},{"ID":"20250206195641-aaepu08","Type":"NodeParagraph","Properties":{"id":"20250206195641-aaepu08","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/3e8b8f7e0ce1a96ad49f0f4fa9debe15.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-456vxtn","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-456vxtn","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003ccstring\u003e\n#include \u003calgorithm\u003e\n#include \u003ccstdio\u003e\nusing namespace std;\ntypedef long long LL;\n\nint qmi(int a,int k,int p)\n{\n    int res=1;\n    while(k)\n    {\n        if(k\u00261) res=(LL)res*a%p;\n        k/=2;\n        a=(LL)a*a%p;\n    }\n    return res;\n}\nint main()\n{\n    int n;\n    cin\u003e\u003en;\n    while(n--)\n    {\n        int a,k,p;\n        cin\u003e\u003ea\u003e\u003ek\u003e\u003ep;\n        cout\u003c\u003cqmi(a,k,p)\u003c\u003cendl;\n    }\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-e8i78n4","Type":"NodeHeading","HeadingLevel":1,"Properties":{"id":"20250206195641-e8i78n4","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"# "},{"Type":"NodeText","Data":"accumulate"}]},{"ID":"20250206195641-70qzzjk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-70qzzjk","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"vector\u003cint\u003e vec = {1, 2, 3, 4, 5};\n// 计算 vec 中所有元素的和，初始值为 0\nint sum = accumulate(vec.begin(), vec.end(), 0);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-j8yfy9y","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20250206195641-j8yfy9y","updated":"20250206195641"},"Children":[{"ID":"20250206195641-ljdppn9","Type":"NodeListItem","Data":"2","ListData":{"Typ":1,"Tight":true,"Start":2,"Delimiter":46,"Padding":3,"Marker":"Mg==","Num":2},"Properties":{"id":"20250206195641-ljdppn9","updated":"20250206195641"},"Children":[{"ID":"20250206195641-rnwblkc","Type":"NodeParagraph","Properties":{"id":"20250206195641-rnwblkc","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"还通过提供自定义的二元操作 op，可以实现不同的聚合操作。例如，计算区间内所有元素的乘积。"}]}]}]},{"ID":"20250206195641-3r77gu0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-3r77gu0","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"vector\u003cint\u003e vec = {1, 2, 3, 4, 5};\n\n // 使用乘法作为操作符计算元素的乘积，初始值为 1\n int product = accumulate(vec.begin(), vec.end(), 1, multiplies\u003cint\u003e());\n\n//multiplies\u003cint\u003e() 是 C++ 标准库中提供的一个函数对象，它执行乘法操作。\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-ebimim0","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20250206195641-ebimim0","updated":"20250206195641"},"Children":[{"ID":"20250206195641-ilo5mu2","Type":"NodeListItem","Data":"3","ListData":{"Typ":1,"Tight":true,"Start":3,"Delimiter":46,"Padding":3,"Marker":"Mw==","Num":3},"Properties":{"id":"20250206195641-ilo5mu2","updated":"20250206195641"},"Children":[{"ID":"20250206195641-kn67z14","Type":"NodeParagraph","Properties":{"id":"20250206195641-kn67z14","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"accumulate 也可以用于其他类型的数据聚合，例如字符串的拼接。通过传入一个适当的操作函数（如加法运算符），可以将一个字符串序列拼接成一个完整的字符串。"}]}]}]},{"ID":"20250206195641-rv3jexm","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-rv3jexm","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"vector\u003cstring\u003e words = {\"Hello\", \" \", \"World\", \"!\"};\n\n// 使用字符串拼接操作，将所有字符串拼接起来\n string result = accumulate(words.begin(), words.end(), string());\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-iasl8dd","Type":"NodeList","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20250206195641-iasl8dd","updated":"20250206195641"},"Children":[{"ID":"20250206195641-2qvf3xz","Type":"NodeListItem","Data":"5","ListData":{"Typ":1,"Tight":true,"Start":5,"Delimiter":46,"Padding":3,"Marker":"NQ==","Num":5},"Properties":{"id":"20250206195641-2qvf3xz","updated":"20250206195641"},"Children":[{"ID":"20250206195641-422tdq0","Type":"NodeParagraph","Properties":{"id":"20250206195641-422tdq0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"如果我们想要找出一组元素中的最大值，也可以使用 accumulate，配合自定义的操作函数（如 std::max）。"}]}]}]},{"ID":"20250206195641-3trymn5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-3trymn5","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"vector\u003cint\u003e vec = {1, 9, 3, 7, 5};\n\n// 使用 max 来查找最大值\nint max_value = accumulate(vec.begin(), vec.end(), vec[0], max\u003cint\u003e());\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-ideqt9l","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-ideqt9l","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"单调栈模板"}]},{"ID":"20250206195641-vkfrv5h","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-vkfrv5h","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"常见模型：找出每个数左边离它最近的比它大/小的数\nint tt = 0;\nfor (int i = 1; i \u003c= n; i ++ )\n{\n    while (tt \u0026\u0026 check(stk[tt], i)) tt -- ;\n    stk[ ++ tt] = i;\n}\n\n-------------------------------------------------------------------------------------------------------------\n\n#include \u003ciostream\u003e\nusing namespace std;\nconst int N = 100010;\nint stk[N], tt;\n \nint main()\n{\n    int n;\n    cin \u003e\u003e n;\n    while (n -- )\n    {\n        int x;\n        scanf(\"%d\", \u0026x);\n        while (tt \u0026\u0026 stk[tt] \u003e= x) tt -- ;//如果栈顶元素大于当前待入栈元素，则出栈\n        if (!tt) printf(\"-1 \");//如果栈空，则没有比该元素小的值。\n        else printf(\"%d \", stk[tt]);//栈顶元素就是左侧第一个比它小的元素。\n        stk[ ++ tt] = x;\n    }\n    return 0;\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-9sh8aqc","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-9sh8aqc","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"单调栈stl实现"}]},{"ID":"20250206195641-73x9x65","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-73x9x65","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003cstack\u003e\nusing namespace std;\n\nint main() {\n    int n;\n    cin \u003e\u003e n;\n    stack\u003cint\u003e st;  // 使用 STL 的栈容器\n\n    while (n--) {\n        int x;\n        cin \u003e\u003e x;  // 读入当前数字\n\n        // 将栈中所有大于等于 x 的元素弹出\n        while (!st.empty() \u0026\u0026 st.top() \u003e= x)\n            st.pop();\n\n        // 如果栈为空，则说明左侧没有比 x 小的数\n        if (st.empty())\n            cout \u003c\u003c \"-1 \";\n        else\n            cout \u003c\u003c st.top() \u003c\u003c \" \";  // 栈顶元素就是左侧第一个比 x 小的数\n\n        // 将当前数字入栈，作为后续数字的候选者\n        st.push(x);\n    }\n    return 0;\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-uru7nmh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-uru7nmh","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"深度优先搜索（DFS）"}]},{"ID":"20250206195641-8ek2ti6","Type":"NodeParagraph","Properties":{"id":"20250206195641-8ek2ti6","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"dfs基本应用：类似树的形式，一直向深处搜索，然后进行回溯。"}]},{"ID":"20250206195641-ni0ouyz","Type":"NodeParagraph","Properties":{"id":"20250206195641-ni0ouyz","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/ac466161c36580f9fd7baddbcb83d389.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-gmmih9a","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-gmmih9a","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003cbits/stdc++.h\u003e\nusing namespace std;\n\nint n;                // 用于存储输入的整数 n，代表全排列的元素个数\nbool st[1000];        // 用于标记某个数字是否已经被使用\nint path[1000];       // 用于存储当前的排列路径\n\n// 深度优先搜索函数，用于生成全排列\nvoid dfs(int u)\n{\n    if (u == n) // 如果当前排列的长度已经达到 n\n    {\n        for (int i = 0; i \u003c n; i++) // 输出当前排列\n            printf(\"%d \", path[i]);\n        puts(\"\"); // 换行\n        return;\n    }\n\n    // 枚举从 1 到 n 的所有数字\n    for (int i = 1; i \u003c= n; i++)\n        if (!st[i]) // 如果数字 i 尚未被使用\n        {\n            path[u] = i;     // 将数字 i 放到当前排列的位置 u\n            st[i] = true;    // 标记数字 i 已经被使用\n            dfs(u + 1);      // 递归调用，进入下一层\n            st[i] = false;   // 回溯，撤销数字 i 的使用标记\n        }\n}\n\nint main()\n{\n    cin \u003e\u003e n; // 输入整数 n\n    dfs(0);   // 从第 0 层开始进行深度优先搜索\n    return 0;\n}\n\n\n\n\n---------------------------------------------------------------------------\n\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\n\nint n; // 输入的整数 n，代表全排列的元素个数\n\nint main() {\n    cin \u003e\u003e n; // 输入整数 n\n\n    stack\u003cpair\u003cvector\u003cint\u003e, vector\u003cbool\u003e\u003e\u003e stk; \n    // 栈中存储的元素为：当前排列路径和数字使用标记\n\n    // 初始化栈，开始时路径为空，所有数字均未被使用\n    vector\u003cint\u003e path;             // 当前排列路径\n    vector\u003cbool\u003e used(n + 1, false); // 标记数组，n+1大小便于直接用数字 1 到 n\n    stk.push({path, used});       // 压入初始状态\n\n    while (!stk.empty()) { // 栈非空时循环\n        auto [path, used] = stk.top(); // 取出栈顶状态\n        stk.pop(); // 弹出栈顶\n\n        if (path.size() == n) { // 如果当前排列长度达到 n，则输出排列\n            for (int x : path) cout \u003c\u003c x \u003c\u003c \" \";\n            cout \u003c\u003c endl;\n            continue;\n        }\n\n        // 枚举从 1 到 n 的所有数字，尝试扩展路径\n        for (int i = n; i \u003e= 1; --i) { // 倒序枚举，保证路径扩展时顺序正确\n            if (!used[i]) { // 如果数字 i 尚未被使用\n                vector\u003cint\u003e new_path = path; // 当前路径的副本\n                vector\u003cbool\u003e new_used = used; // 当前标记数组的副本\n                new_path.push_back(i);        // 添加数字 i 到路径\n                new_used[i] = true;           // 标记数字 i 已被使用\n                stk.push({new_path, new_used}); // 将新状态压入栈\n            }\n        }\n    }\n\n    return 0;\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-r6dkzsr","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20250206195641-r6dkzsr","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### "},{"Type":"NodeText","Data":"n皇后问题中，一个坐标是u,i的点，在u+i这条对角线上，也在n-u+i这条"},{"Type":"NodeTextMark","Properties":{"style":"color: var(--b3-font-color8);"},"TextMarkType":"text","TextMarkTextContent":"反"},{"Type":"NodeText","Data":"对角线上。"}]},{"ID":"20250206195641-h8ywvwh","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-h8ywvwh","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"广度优先搜索(BFS)"}]},{"ID":"20250206195641-j979kjj","Type":"NodeParagraph","Properties":{"id":"20250206195641-j979kjj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"bfs:一层一层地向外进行扩展，直到搜到终点位置，本质是队列，最先搜到的位置一定是最短路径，所以bfs有最短路径。"}]},{"ID":"20250206195641-sv2z7t4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-sv2z7t4","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003cbits/stdc++.h\u003e\nusing namespace std;\n\nconst int N = 110; // 假设网格的最大边长为 110\ntypedef pair\u003cint, int\u003e PII; // 定义坐标点的类型 (x, y)\n\n// 定义全局变量\nint d[N][N];     // 距离数组，存储每个点到起点的最短路径长度\nint g[N][N];     // 网格数组，输入地图\nbool st[N][N];   // 标记数组，判断某点是否已经访问过\nint n, m;        // 网格的大小 n 行 m 列\nPII Pre[N][N];   // 记录路径的前驱节点，用于输出路径\n\n// 宽度优先搜索（BFS）\nint bfs() {\n    queue\u003cPII\u003e q;          // 定义队列\n    q.push({1, 1});        // 把起始位置放入队列\n    st[1][1] = true;       // 标记起点已访问\n    d[1][1] = 0;           // 起点到起点的距离为 0\n\n    // 定义方向数组，用于上下左右的四个方向\n    int dx[4] = {-1, 0, 1, 0}, dy[4] = {0, 1, 0, -1};\n\n    while (!q.empty()) { // 当队列不为空\n        auto t = q.front(); // 取出队头元素\n        q.pop();            // 弹出队头元素\n\n        for (int i = 0; i \u003c 4; i++) { // 枚举四个方向\n            int x = t.first + dx[i], y = t.second + dy[i]; // 新的坐标\n            // 检查新坐标是否有效：1. 不越界；2. 是空地；3. 没访问过\n            if (x \u003e= 1 \u0026\u0026 x \u003c= n \u0026\u0026 y \u003e= 1 \u0026\u0026 y \u003c= m \u0026\u0026 g[x][y] == 0 \u0026\u0026 !st[x][y]) {\n                d[x][y] = d[t.first][t.second] + 1; // 更新距离\n                Pre[x][y] = t;                     // 记录路径的前驱节点\n                q.push({x, y});                    // 新点入队\n                st[x][y] = true;                   // 标记新点已访问\n            }\n        }\n    }\n\n    /*\n    如果需要输出路径，可以启用这段代码：\n    int x = n, y = m; // 从终点回溯路径\n    while (x || y) {\n        cout \u003c\u003c x \u003c\u003c \" \" \u003c\u003c y \u003c\u003c endl; // 输出路径点\n        auto t = Pre[x][y]; // 找到当前点的前驱\n        x = t.first, y = t.second; // 回到前驱点\n    }\n    */\n\n    return d[n][m]; // 返回终点的最短路径长度\n}\n\nint main() {\n    // 输入网格大小\n    scanf(\"%d%d\", \u0026n, \u0026m);\n\n    // 输入网格数据\n    for (int i = 1; i \u003c= n; i++)\n        for (int j = 1; j \u003c= m; j++)\n            cin \u003e\u003e g[i][j];\n\n    // 输出从起点到终点的最短路径长度\n    printf(\"%d\\n\", bfs());\n    return 0;\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-cqnx9ij","Type":"NodeThematicBreak","Properties":{"id":"20250206195641-cqnx9ij","updated":"20250206195641"}},{"ID":"20250206195641-ardvknm","Type":"NodeParagraph","Properties":{"id":"20250206195641-ardvknm","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"‍"}]},{"ID":"20250206195641-vd318hy","Type":"NodeHeading","HeadingLevel":5,"Properties":{"id":"20250206195641-vd318hy","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"##### "},{"Type":"NodeText","Data":"cin.tie(0);和ios::sync_with_stdio(false);可以提升效率。"}]},{"ID":"20250206195641-yfi1scr","Type":"NodeThematicBreak","Properties":{"id":"20250206195641-yfi1scr","updated":"20250206195641"}},{"ID":"20250206195641-5cmm1hu","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-5cmm1hu","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"单链表"}]},{"ID":"20250206195641-d8sq05i","Type":"NodeParagraph","Properties":{"id":"20250206195641-d8sq05i","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"实现一个单链表，链表初始为空，支持三种操作："}]},{"ID":"20250206195641-2i3uu41","Type":"NodeParagraph","Properties":{"id":"20250206195641-2i3uu41","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"向链表头插入一个数；"}]},{"ID":"20250206195641-lddp4u0","Type":"NodeParagraph","Properties":{"id":"20250206195641-lddp4u0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"删除第 k 个插入的数后面的数；"}]},{"ID":"20250206195641-ybo29eh","Type":"NodeParagraph","Properties":{"id":"20250206195641-ybo29eh","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"在第 k个插入的数后插入一个数。"}]},{"ID":"20250206195641-qddgoqd","Type":"NodeParagraph","Properties":{"id":"20250206195641-qddgoqd","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"现在要对该链表进行 M次操作，进行完所有操作后，从头到尾输出整个链表。"}]},{"ID":"20250206195641-1o8svp6","Type":"NodeParagraph","Properties":{"id":"20250206195641-1o8svp6","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"注意:题目中第 k 个插入的数并不是指当前链表的第 k个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。"}]},{"ID":"20250206195641-x6spq5y","Type":"NodeParagraph","Properties":{"id":"20250206195641-x6spq5y","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-8szunoq","Type":"NodeParagraph","Properties":{"id":"20250206195641-8szunoq","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含整数 M，表示操作次数。"}]},{"ID":"20250206195641-tphipcv","Type":"NodeParagraph","Properties":{"id":"20250206195641-tphipcv","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种："}]},{"ID":"20250206195641-b4nf6kl","Type":"NodeParagraph","Properties":{"id":"20250206195641-b4nf6kl","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"H x，表示向链表头插入一个数 x。"}]},{"ID":"20250206195641-ahqhhjy","Type":"NodeParagraph","Properties":{"id":"20250206195641-ahqhhjy","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"D k，表示删除第 k个插入的数后面的数（当 k为 0 时，表示删除头结点）。"}]},{"ID":"20250206195641-2yqu4sx","Type":"NodeParagraph","Properties":{"id":"20250206195641-2yqu4sx","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"I k x，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。"}]},{"ID":"20250206195641-vmb66zt","Type":"NodeParagraph","Properties":{"id":"20250206195641-vmb66zt","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-rl8nb62","Type":"NodeParagraph","Properties":{"id":"20250206195641-rl8nb62","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"共一行，将整个链表从头到尾输出。"}]},{"ID":"20250206195641-6014hq1","Type":"NodeParagraph","Properties":{"id":"20250206195641-6014hq1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-6dsmu6b","Type":"NodeParagraph","Properties":{"id":"20250206195641-6dsmu6b","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤M≤100000"}]},{"ID":"20250206195641-z2dq72m","Type":"NodeParagraph","Properties":{"id":"20250206195641-z2dq72m","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"所有操作保证合法。"}]},{"ID":"20250206195641-5mq98xu","Type":"NodeParagraph","Properties":{"id":"20250206195641-5mq98xu","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-3s5r0m6","Type":"NodeParagraph","Properties":{"id":"20250206195641-3s5r0m6","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"10"}]},{"ID":"20250206195641-3erhawu","Type":"NodeParagraph","Properties":{"id":"20250206195641-3erhawu","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"H 9"}]},{"ID":"20250206195641-369jdrd","Type":"NodeParagraph","Properties":{"id":"20250206195641-369jdrd","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"I 1 1"}]},{"ID":"20250206195641-nt5z1xu","Type":"NodeParagraph","Properties":{"id":"20250206195641-nt5z1xu","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"D 1"}]},{"ID":"20250206195641-8ngk4vx","Type":"NodeParagraph","Properties":{"id":"20250206195641-8ngk4vx","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"D 0"}]},{"ID":"20250206195641-kpobo7l","Type":"NodeParagraph","Properties":{"id":"20250206195641-kpobo7l","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"H 6"}]},{"ID":"20250206195641-w72ewts","Type":"NodeParagraph","Properties":{"id":"20250206195641-w72ewts","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"I 3 6"}]},{"ID":"20250206195641-0ud0g8q","Type":"NodeParagraph","Properties":{"id":"20250206195641-0ud0g8q","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"I 4 5"}]},{"ID":"20250206195641-7whg6qp","Type":"NodeParagraph","Properties":{"id":"20250206195641-7whg6qp","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"I 4 5"}]},{"ID":"20250206195641-6udg5ee","Type":"NodeParagraph","Properties":{"id":"20250206195641-6udg5ee","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"I 3 4"}]},{"ID":"20250206195641-nf2lvg1","Type":"NodeParagraph","Properties":{"id":"20250206195641-nf2lvg1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"D 6"}]},{"ID":"20250206195641-9ej8f6p","Type":"NodeParagraph","Properties":{"id":"20250206195641-9ej8f6p","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-azaq7nr","Type":"NodeParagraph","Properties":{"id":"20250206195641-azaq7nr","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"6 4 6 5"}]},{"ID":"20250206195641-a0ip7pd","Type":"NodeParagraph","Properties":{"id":"20250206195641-a0ip7pd","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/629fe2b5558d362425ea4a6c9d30387d.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-t7ddvic","Type":"NodeParagraph","Properties":{"id":"20250206195641-t7ddvic","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"我们用-1表示空指针。"}]},{"ID":"20250206195641-c0s85g8","Type":"NodeParagraph","Properties":{"id":"20250206195641-c0s85g8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"实现一些基本的操作："}]},{"ID":"20250206195641-mbz0bq0","Type":"NodeParagraph","Properties":{"id":"20250206195641-mbz0bq0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(1)初始化"}]},{"ID":"20250206195641-yeq69sh","Type":"NodeParagraph","Properties":{"id":"20250206195641-yeq69sh","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"头节点指向-1表示空节点,idx"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"0表示从0好节点进行编号。"}]},{"ID":"20250206195641-ddysy8q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-ddysy8q","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"void init()//链表的初始化\n{\n    head=-1;//头节点指向空节点\n    idx=0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-xbl4kgg","Type":"NodeParagraph","Properties":{"id":"20250206195641-xbl4kgg","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(2)向头节点后面插入一个新节点"}]},{"ID":"20250206195641-rj7vwws","Type":"NodeParagraph","Properties":{"id":"20250206195641-rj7vwws","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/0487075fb3da0c6345ad8a12a751c5fd.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-02e9v4d","Type":"NodeParagraph","Properties":{"id":"20250206195641-02e9v4d","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(3)向第k个插入的点后面添加一个点同(2)"}]},{"ID":"20250206195641-eolo990","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-eolo990","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"void add(int k,int x)//向第k个插入的数后面插入一个数\n{\n    e[idx]=x,ne[idx]=ne[k],ne[k]=idx++;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-z0kqhbo","Type":"NodeParagraph","Properties":{"id":"20250206195641-z0kqhbo","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"因为是从0号节点进行编号的，所以第k个插入的点其实是第k-1个点add(k-1,x);"}]},{"ID":"20250206195641-9w3aduj","Type":"NodeParagraph","Properties":{"id":"20250206195641-9w3aduj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(4)删除头节点"}]},{"ID":"20250206195641-r5o3bij","Type":"NodeParagraph","Properties":{"id":"20250206195641-r5o3bij","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/5b0709f78562e68a8f9a91601bacd67c.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-328gg4l","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-328gg4l","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"void remove()//删除头节点\n{\n    head=ne[head];\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-2iy654t","Type":"NodeParagraph","Properties":{"id":"20250206195641-2iy654t","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(5)删除第k个插入的点"}]},{"ID":"20250206195641-lrnmsjj","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-lrnmsjj","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"void de(int k)//删除第k个插入的数\n{\n    ne[k]=ne[ne[k]];\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-jjwfdnq","Type":"NodeParagraph","Properties":{"id":"20250206195641-jjwfdnq","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"remove(k-1);"}]},{"ID":"20250206195641-kl2tgzp","Type":"NodeParagraph","Properties":{"id":"20250206195641-kl2tgzp","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"AC代码"}]},{"ID":"20250206195641-pcqzrtx","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-pcqzrtx","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003cbits/stdc++.h\u003e\n#include\u003cstring\u003e\nusing namespace std;\nconst int N=1e6+10;\nint head,e[N],ne[N],idx;\n\nvoid init()//链表的初始化\n{\n    head=-1;\n    idx=0;\n}\n\nvoid add_head(int x)//向头节点之后插入一个数\n{\n    e[idx]=x,ne[idx]=head,head=idx++;\n}\n\nvoid add(int k,int x)//向第k个插入的数后面插入一个数\n{\n    e[idx]=x,ne[idx]=ne[k],ne[k]=idx++;\n}\n\nvoid de(int k)//删除第k个插入的数\n{\n    ne[k]=ne[ne[k]];\n}\n\nvoid remove()//删除头节点\n{\n    head=ne[head];\n}\n\nint main()\n{\n    int t;\n    scanf(\"%d\",\u0026t);\n    init();\n    while(t--){\n        string op;\n        int k,x;\n        cin\u003e\u003eop;\n        if(op==\"H\"){\n            scanf(\"%d\",\u0026x);\n            add_head(x);\n        }\n        else if(op==\"D\"){\n            scanf(\"%d\",\u0026k);\n            if(k==0) remove();\n            de(k-1);\n        }\n        else{\n            scanf(\"%d%d\",\u0026k,\u0026x);\n            add(k-1,x);\n        }\n    }\n    for(int i=head;i!=-1;i=ne[i])\n        cout\u003c\u003ce[i]\u003c\u003c\" \";\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-87dmnx3","Type":"NodeThematicBreak","Properties":{"id":"20250206195641-87dmnx3","updated":"20250206195641"}},{"ID":"20250206195641-mtgg4ux","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-mtgg4ux","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"快速排序"}]},{"ID":"20250206195641-xymlo8e","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-xymlo8e","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003cbits/stdc++.h\u003e\nusing namespace std;\nconst int N=100010;  // 定义数组最大容量\nint q[N];            // 静态分配数组，避免动态内存开销\n\n/**\n * 快速排序函数（双指针法）\n * @param q[] 待排序数组\n * @param l 当前区间的左边界\n * @param r 当前区间的右边界\n * 时间复杂度: 平均O(nlogn)，最坏O(n²)\n * 空间复杂度: O(logn) 递归栈空间\n */\nvoid quick_sort(int q[], int l, int r) {\n    // 递归终止条件：区间长度\u003c=1时无需排序\n    if (l \u003e= r) return;\n  \n    // 选取中间元素作为基准值（比经典选首元素更抗退化）\n    int x = q[l + r \u003e\u003e 1];  // 位运算等效 (l+r)/2\n    int i = l - 1;          // 左扫描指针（从界外开始）\n    int j = r + 1;          // 右扫描指针（从界外开始）\n\n    // 核心分区逻辑：将数组分为\u003c=x和\u003e=x的两部分\n    while (i \u003c j) {\n        // 找到左边第一个 \u003e=x 的元素\n        do i++; while (q[i] \u003c x);  // 注意没有等号，保证稳定性\n      \n        // 找到右边第一个 \u003c=x 的元素\n        do j--; while (q[j] \u003e x);  // 注意没有等号，保证稳定性\n      \n        // 当指针未交叉时交换元素\n        if (i \u003c j) swap(q[i], q[j]);\n    }\n\n    // 递归处理子区间（选择j作为分界点保证区间分裂）\n    quick_sort(q, l, j);      // 处理左半区间\n    quick_sort(q, j + 1, r);  // 处理右半区间\n}\n\nint main() {\n    int n;\n    cin \u003e\u003e n;\n  \n    // 输入数据\n    for (int i = 0; i \u003c n; i++) \n        cin \u003e\u003e q[i];\n  \n    // 调用快速排序\n    quick_sort(q, 0, n - 1);\n  \n    // 输出排序结果\n    for (int i = 0; i \u003c n; i++) \n        cout \u003c\u003c q[i] \u003c\u003c \" \";\n  \n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-kazfwri","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-kazfwri","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"归并排序"}]},{"ID":"20250206195641-a8cct07","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-a8cct07","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003cbits/stdc++.h\u003e\nusing namespace std;\n\nconst int N = 100010;  // 定义数组的最大容量\n\nint q[N], tmp[N];  // q 数组用于存放待排序的数据，tmp 数组用于归并排序时的临时存储\n\n// 归并排序函数，参数 q 是数组，l 和 r 分别是当前排序区间的左右边界索引\nvoid merge_sort(int q[], int l, int r) {\n    // 如果区间内只有一个元素或无元素，则无需排序，直接返回\n    if(l \u003e= r) return;\n  \n    // 计算中间位置\n    int mid = l + r \u003e\u003e 1;  // 注意：这里等同于 mid = (l + r) / 2\n  \n    // 对左右两个子区间分别进行归并排序\n    merge_sort(q, l, mid);\n    merge_sort(q, mid + 1, r);\n  \n    // 合并两个已排序的子区间\n    int k = 0;  // tmp 数组的索引\n    int i = l, j = mid + 1;  // 两个子区间的起始索引\n  \n    // 当两个子区间都未遍历完时，比较两边元素，将较小的元素存入 tmp 数组中\n    while(i \u003c= mid \u0026\u0026 j \u003c= r)\n        if(q[i] \u003c q[j])\n            tmp[k++] = q[i++];  // 如果左边元素较小，存入 tmp，并移动左边索引\n        else\n            tmp[k++] = q[j++];  // 否则存入右边元素，并移动右边索引\n  \n    // 将剩余的左子区间元素存入 tmp（如果有剩余的话）\n    while(i \u003c= mid)\n        tmp[k++] = q[i++];\n  \n    // 将剩余的右子区间元素存入 tmp（如果有剩余的话）\n    while(j \u003c= r)\n        tmp[k++] = q[j++];\n  \n    // 将排好序的 tmp 数组复制回原数组对应位置\n    for(i = l, j = 0; i \u003c= r; i++, j++)\n        q[i] = tmp[j];\n}\n\nint main()\n{\n    int n;\n    // 读取数据个数\n    scanf(\"%d\", \u0026n);\n  \n    // 读取 n 个整数存入数组 q\n    for(int i = 0; i \u003c n; i++) \n        scanf(\"%d\", \u0026q[i]);\n  \n    // 对整个数组进行归并排序\n    merge_sort(q, 0, n - 1);\n  \n    // 输出排序后的数组\n    for(int i = 0; i \u003c n; i++)\n        cout \u003c\u003c q[i] \u003c\u003c \" \";\n  \n    return 0;\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-wo0plm0","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-wo0plm0","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"位运算"}]},{"ID":"20250206195641-ek532u1","Type":"NodeParagraph","Properties":{"id":"20250206195641-ek532u1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"\u0026:按位与,1\u00260"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"0,0\u00261"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"0,0\u00260"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"0,1\u00261"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"1,只有都为1时才为1."}]},{"ID":"20250206195641-0ibgaw5","Type":"NodeParagraph","Properties":{"id":"20250206195641-0ibgaw5","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"|:按位或,1|1"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"1,1|0"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"1,0|1"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"1,0|0"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"0,只有都为0时才为0."}]},{"ID":"20250206195641-8kwwenk","Type":"NodeParagraph","Properties":{"id":"20250206195641-8kwwenk","updated":"20250206195641"},"Children":[{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"^"}]},{"Type":"NodeText","Data":":按位异或,1"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"^"}]},{"Type":"NodeText","Data":"1"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"0,1"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"^"}]},{"Type":"NodeText","Data":"0"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"1,0"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"^"}]},{"Type":"NodeText","Data":"a"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"a,相同为0，不同为非0的那个数."}]},{"ID":"20250206195641-m1pctp7","Type":"NodeParagraph","Properties":{"id":"20250206195641-m1pctp7","updated":"20250206195641"},"Children":[{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"\u003e"}]},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"\u003e"}]},{"Type":"NodeText","Data":":右移，a"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"\u003e"}]},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"\u003e"}]},{"Type":"NodeText","Data":"x,表示a除以2"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"^"}]},{"Type":"NodeText","Data":"x;"}]},{"ID":"20250206195641-aawp36b","Type":"NodeParagraph","Properties":{"id":"20250206195641-aawp36b","updated":"20250206195641"},"Children":[{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"\u003c"}]},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"\u003c"}]},{"Type":"NodeText","Data":":左移，a"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"\u003c"}]},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"\u003c"}]},{"Type":"NodeText","Data":"x,表示a乘2"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"^"}]},{"Type":"NodeText","Data":"x;"}]},{"ID":"20250206195641-6kn5vfe","Type":"NodeParagraph","Properties":{"id":"20250206195641-6kn5vfe","updated":"20250206195641"},"Children":[{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"~"}]},{"Type":"NodeText","Data":":把0变成1，把1变成0；"}]},{"ID":"20250206195641-9hcouww","Type":"NodeParagraph","Properties":{"id":"20250206195641-9hcouww","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"-x"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"~"}]},{"Type":"NodeText","Data":"x+1;"}]},{"ID":"20250206195641-q2vfpj6","Type":"NodeParagraph","Properties":{"id":"20250206195641-q2vfpj6","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(1)lowbit(x)"}]},{"ID":"20250206195641-xs2sb5r","Type":"NodeParagraph","Properties":{"id":"20250206195641-xs2sb5r","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"将十进制数的二进制表示的最低位1取出来。"}]},{"ID":"20250206195641-g51jye6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-g51jye6","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"int lowbit(int x)\n{\n    return x\u0026-x;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-5lbj86u","Type":"NodeParagraph","Properties":{"id":"20250206195641-5lbj86u","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"如x的二进制表示时100,-x在计算机中为"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"~"}]},{"Type":"NodeText","Data":"x+1,则"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"~"}]},{"Type":"NodeText","Data":"x"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"011,"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"~"}]},{"Type":"NodeText","Data":"x+1"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"111,那么就有"}]},{"ID":"20250206195641-pkwo1ra","Type":"NodeParagraph","Properties":{"id":"20250206195641-pkwo1ra","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(100)\u0026(111)"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"(100)，这样就可以把最低位上面的1取出来。"}]},{"ID":"20250206195641-2e3plf9","Type":"NodeParagraph","Properties":{"id":"20250206195641-2e3plf9","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(2)把n对应二进制表示中第k位取出来(注意有第0位)"}]},{"ID":"20250206195641-7334iwv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-7334iwv","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"int get(int n,int k)\n{\n    return n\u003e\u003ek\u00261;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-fh24jb4","Type":"NodeParagraph","Properties":{"id":"20250206195641-fh24jb4","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(3)输出所有小于k的十进制"}]},{"ID":"20250206195641-f5yo3xu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-f5yo3xu","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"for(int i=0;i\u003c1\u003c\u003ck;i++)\n    cout\u003c\u003ci;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-zf8pnt2","Type":"NodeThematicBreak","Properties":{"id":"20250206195641-zf8pnt2","updated":"20250206195641"}},{"ID":"20250206195641-pa3dnqh","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-pa3dnqh","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"区间合并"}]},{"ID":"20250206195641-jr3yh7l","Type":"NodeParagraph","Properties":{"id":"20250206195641-jr3yh7l","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"给定 n 个区间 [li,ri]，要求合并所有有交集的区间。"}]},{"ID":"20250206195641-o5yhale","Type":"NodeParagraph","Properties":{"id":"20250206195641-o5yhale","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"注意如果在端点处相交，也算有交集。"}]},{"ID":"20250206195641-o659p39","Type":"NodeParagraph","Properties":{"id":"20250206195641-o659p39","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出合并完成后的区间个数。"}]},{"ID":"20250206195641-j8euxep","Type":"NodeParagraph","Properties":{"id":"20250206195641-j8euxep","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"例如：[1,3] 和 [2,6] 可以合并为一个区间 [1,6]。"}]},{"ID":"20250206195641-3s4ssrc","Type":"NodeParagraph","Properties":{"id":"20250206195641-3s4ssrc","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-jr7rhyf","Type":"NodeParagraph","Properties":{"id":"20250206195641-jr7rhyf","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含整数 nn。"}]},{"ID":"20250206195641-wzv0799","Type":"NodeParagraph","Properties":{"id":"20250206195641-wzv0799","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"接下来 nn 行，每行包含两个整数 l 和 r。"}]},{"ID":"20250206195641-1lht7wg","Type":"NodeParagraph","Properties":{"id":"20250206195641-1lht7wg","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-4tnb0y1","Type":"NodeParagraph","Properties":{"id":"20250206195641-4tnb0y1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"共一行，包含一个整数，表示合并区间完成后的区间个数。"}]},{"ID":"20250206195641-mnyt86p","Type":"NodeParagraph","Properties":{"id":"20250206195641-mnyt86p","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-wpceuty","Type":"NodeParagraph","Properties":{"id":"20250206195641-wpceuty","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤n≤100000,"}]},{"ID":"20250206195641-tjmo9el","Type":"NodeParagraph","Properties":{"id":"20250206195641-tjmo9el","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"−109≤li≤ri≤109"}]},{"ID":"20250206195641-cw43yqo","Type":"NodeParagraph","Properties":{"id":"20250206195641-cw43yqo","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-i2t54se","Type":"NodeParagraph","Properties":{"id":"20250206195641-i2t54se","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"5"}]},{"ID":"20250206195641-zdr9zlg","Type":"NodeParagraph","Properties":{"id":"20250206195641-zdr9zlg","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1 2"}]},{"ID":"20250206195641-b37nd2k","Type":"NodeParagraph","Properties":{"id":"20250206195641-b37nd2k","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2 4"}]},{"ID":"20250206195641-11g0bq0","Type":"NodeParagraph","Properties":{"id":"20250206195641-11g0bq0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"5 6"}]},{"ID":"20250206195641-g5h27f8","Type":"NodeParagraph","Properties":{"id":"20250206195641-g5h27f8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"7 8"}]},{"ID":"20250206195641-itkvtuv","Type":"NodeParagraph","Properties":{"id":"20250206195641-itkvtuv","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"7 9"}]},{"ID":"20250206195641-s49oye6","Type":"NodeParagraph","Properties":{"id":"20250206195641-s49oye6","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-l8tkh6g","Type":"NodeParagraph","Properties":{"id":"20250206195641-l8tkh6g","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"3"}]},{"ID":"20250206195641-1sk54vw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-1sk54vw","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003cvector\u003e\n#include \u003calgorithm\u003e\n \nusing namespace std;\n \n// 定义一个 pair 类型，表示区间，first 表示区间的左端点，second 表示右端点\ntypedef pair\u003cint, int\u003e PII;\n \nint n;  // 区间的数量\n \n// merge 函数用于合并重叠的区间，输入参数 interval 为区间集合\nvoid merge(vector\u003cPII\u003e \u0026interval)\n{\n    // 用 ans 存储合并后的区间结果\n    vector\u003cPII\u003e ans;\n \n    // 对区间进行排序，排序规则是先按照区间的左端点升序，\n    // 如果左端点相同，则按照右端点升序排序\n    sort(interval.begin(), interval.end()); //! pair排序 优先左端点， 再以右端点排序\n \n    // 初始化当前区间的左右边界 st 和 ed\n    // 初始化为一个很小的值，确保第一次比较时一定满足条件 ed \u003c item.first\n    int st = -1e9 - 10, ed = -1e9 - 10;  //! 只要比 -1e9 小就可以\n \n    // 遍历排序后的区间\n    for(auto item : interval)\n    {\n        // 如果当前区间与遍历到的区间没有重叠（即当前区间的结束点小于新区间的起始点）\n        if(ed \u003c item.first)\n        {\n            // 如果 st 不是初始值，则说明前面存在一个合法区间，加入 ans\n            if(st != -1e9 - 10)\n                ans.push_back({st, ed}); //! 第一次在这里初始化\n \n            // 更新当前区间为新区间\n            st = item.first;\n            ed = item.second; //! 第一段区间从这里开始\n        }\n        else\n        {\n            // 如果有重叠，则更新当前区间的结束点为两个区间结束点的最大值\n            ed = max(ed, item.second);\n        }\n    }\n    // todo 这个循环结束之后还会剩下一个未加入的区间\n    // 最后一次合并后的区间需要加入结果中\n    if(st != -1e9 - 10)\n        ans.push_back({st, ed});  //! 如果不是空的  那我们就加上一段\n \n    // 更新输入的区间集合为合并后的结果\n    interval = ans;\n}\n \nint main(void)\n{\n    // 提高输入输出效率\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n \n    // 输入区间数量\n    cin \u003e\u003e n;\n \n    // 定义一个 vector 用来存储所有区间\n    vector\u003cPII\u003e interval;\n    while(n--)\n    {\n        int l, r;\n        // 输入每个区间的左右端点\n        cin \u003e\u003e l \u003e\u003e r;\n \n        // 将输入的区间加入集合\n        interval.push_back({l, r});\n    }\n \n    // 调用 merge 函数合并所有重叠区间\n    merge(interval);\n \n    // 输出合并后区间的数量\n    cout \u003c\u003c interval.size() \u003c\u003c endl;\n \n    return 0;\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-e38q2cs","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-e38q2cs","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "}]},{"ID":"20250206195641-47k5jf9","Type":"NodeParagraph","Properties":{"id":"20250206195641-47k5jf9","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"用数组模拟链表。"}]},{"ID":"20250206195641-imkuwaj","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-imkuwaj","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"单链表"}]},{"ID":"20250206195641-c79umo2","Type":"NodeParagraph","Properties":{"id":"20250206195641-c79umo2","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"实现一个单链表，链表初始为空，支持三种操作："}]},{"ID":"20250206195641-4doh3b4","Type":"NodeParagraph","Properties":{"id":"20250206195641-4doh3b4","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"向链表头插入一个数；"}]},{"ID":"20250206195641-0sk42sf","Type":"NodeParagraph","Properties":{"id":"20250206195641-0sk42sf","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"删除第 k 个插入的数后面的数；"}]},{"ID":"20250206195641-pfgbq9f","Type":"NodeParagraph","Properties":{"id":"20250206195641-pfgbq9f","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"在第 k个插入的数后插入一个数。"}]},{"ID":"20250206195641-1o01314","Type":"NodeParagraph","Properties":{"id":"20250206195641-1o01314","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"现在要对该链表进行 M次操作，进行完所有操作后，从头到尾输出整个链表。"}]},{"ID":"20250206195641-d506zoo","Type":"NodeParagraph","Properties":{"id":"20250206195641-d506zoo","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"注意:题目中第 k 个插入的数并不是指当前链表的第 k个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。"}]},{"ID":"20250206195641-h3hc50f","Type":"NodeParagraph","Properties":{"id":"20250206195641-h3hc50f","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-77ca2km","Type":"NodeParagraph","Properties":{"id":"20250206195641-77ca2km","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含整数 M，表示操作次数。"}]},{"ID":"20250206195641-2nmn4t8","Type":"NodeParagraph","Properties":{"id":"20250206195641-2nmn4t8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种："}]},{"ID":"20250206195641-2tu7ja9","Type":"NodeParagraph","Properties":{"id":"20250206195641-2tu7ja9","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"H x，表示向链表头插入一个数 x。"}]},{"ID":"20250206195641-m8wpm2j","Type":"NodeParagraph","Properties":{"id":"20250206195641-m8wpm2j","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"D k，表示删除第 k个插入的数后面的数（当 k为 0 时，表示删除头结点）。"}]},{"ID":"20250206195641-96s2u0r","Type":"NodeParagraph","Properties":{"id":"20250206195641-96s2u0r","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"I k x，表示在第 k 个插入的数后面插入一个数 x（此操作中 k 均大于 0）。"}]},{"ID":"20250206195641-szvo6kn","Type":"NodeParagraph","Properties":{"id":"20250206195641-szvo6kn","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-t1pb333","Type":"NodeParagraph","Properties":{"id":"20250206195641-t1pb333","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"共一行，将整个链表从头到尾输出。"}]},{"ID":"20250206195641-6yfvckm","Type":"NodeParagraph","Properties":{"id":"20250206195641-6yfvckm","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-7calefk","Type":"NodeParagraph","Properties":{"id":"20250206195641-7calefk","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤M≤100000"}]},{"ID":"20250206195641-wx7gg2e","Type":"NodeParagraph","Properties":{"id":"20250206195641-wx7gg2e","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"所有操作保证合法。"}]},{"ID":"20250206195641-s7z6cuu","Type":"NodeParagraph","Properties":{"id":"20250206195641-s7z6cuu","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-k9hla82","Type":"NodeParagraph","Properties":{"id":"20250206195641-k9hla82","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"10"}]},{"ID":"20250206195641-r647kyc","Type":"NodeParagraph","Properties":{"id":"20250206195641-r647kyc","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"H 9"}]},{"ID":"20250206195641-zixo9bg","Type":"NodeParagraph","Properties":{"id":"20250206195641-zixo9bg","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"I 1 1"}]},{"ID":"20250206195641-0kcf6pi","Type":"NodeParagraph","Properties":{"id":"20250206195641-0kcf6pi","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"D 1"}]},{"ID":"20250206195641-az586n5","Type":"NodeParagraph","Properties":{"id":"20250206195641-az586n5","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"D 0"}]},{"ID":"20250206195641-20esg9s","Type":"NodeParagraph","Properties":{"id":"20250206195641-20esg9s","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"H 6"}]},{"ID":"20250206195641-1ohsqxg","Type":"NodeParagraph","Properties":{"id":"20250206195641-1ohsqxg","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"I 3 6"}]},{"ID":"20250206195641-4ucbfbv","Type":"NodeParagraph","Properties":{"id":"20250206195641-4ucbfbv","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"I 4 5"}]},{"ID":"20250206195641-9hqpwhw","Type":"NodeParagraph","Properties":{"id":"20250206195641-9hqpwhw","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"I 4 5"}]},{"ID":"20250206195641-nhef8c8","Type":"NodeParagraph","Properties":{"id":"20250206195641-nhef8c8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"I 3 4"}]},{"ID":"20250206195641-asq95a6","Type":"NodeParagraph","Properties":{"id":"20250206195641-asq95a6","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"D 6"}]},{"ID":"20250206195641-mjv5r17","Type":"NodeParagraph","Properties":{"id":"20250206195641-mjv5r17","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-b1zl17b","Type":"NodeParagraph","Properties":{"id":"20250206195641-b1zl17b","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"6 4 6 5"}]},{"ID":"20250206195641-afiqgp1","Type":"NodeParagraph","Properties":{"id":"20250206195641-afiqgp1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/629fe2b5558d362425ea4a6c9d30387d.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-xg6553j","Type":"NodeParagraph","Properties":{"id":"20250206195641-xg6553j","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"我们用-1表示空指针。"}]},{"ID":"20250206195641-wh5jhqo","Type":"NodeParagraph","Properties":{"id":"20250206195641-wh5jhqo","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"实现一些基本的操作："}]},{"ID":"20250206195641-e1btrw6","Type":"NodeParagraph","Properties":{"id":"20250206195641-e1btrw6","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(1)初始化"}]},{"ID":"20250206195641-4e3y0m7","Type":"NodeParagraph","Properties":{"id":"20250206195641-4e3y0m7","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"头节点指向-1表示空节点,idx"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"0表示从0好节点进行编号。"}]},{"ID":"20250206195641-63egh8v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-63egh8v","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"void init()//链表的初始化\n{\n    head=-1;//头节点指向空节点\n    idx=0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-ld2o7en","Type":"NodeParagraph","Properties":{"id":"20250206195641-ld2o7en","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(2)向头节点后面插入一个新节点"}]},{"ID":"20250206195641-mfdiqnj","Type":"NodeParagraph","Properties":{"id":"20250206195641-mfdiqnj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/0487075fb3da0c6345ad8a12a751c5fd.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-yt3eprr","Type":"NodeParagraph","Properties":{"id":"20250206195641-yt3eprr","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(3)向第k个插入的点后面添加一个点同(2)"}]},{"ID":"20250206195641-wpignml","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-wpignml","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"void add(int k,int x)//向第k个插入的数后面插入一个数\n{\n    e[idx]=x,ne[idx]=ne[k],ne[k]=idx++;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-pxn2btu","Type":"NodeParagraph","Properties":{"id":"20250206195641-pxn2btu","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"因为是从0号节点进行编号的，所以第k个插入的点其实是第k-1个点add(k-1,x);"}]},{"ID":"20250206195641-7yzh4vt","Type":"NodeParagraph","Properties":{"id":"20250206195641-7yzh4vt","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(4)删除头节点"}]},{"ID":"20250206195641-73reume","Type":"NodeParagraph","Properties":{"id":"20250206195641-73reume","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/5b0709f78562e68a8f9a91601bacd67c.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-8e96qex","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-8e96qex","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"void remove()//删除头节点\n{\n    head=ne[head];\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-i9yegep","Type":"NodeParagraph","Properties":{"id":"20250206195641-i9yegep","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(5)删除第k个插入的点"}]},{"ID":"20250206195641-9uhndce","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-9uhndce","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"void de(int k)//删除第k个插入的数\n{\n    ne[k]=ne[ne[k]];\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-xq52199","Type":"NodeParagraph","Properties":{"id":"20250206195641-xq52199","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"remove(k-1);"}]},{"ID":"20250206195641-5on4k7z","Type":"NodeParagraph","Properties":{"id":"20250206195641-5on4k7z","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"AC代码"}]},{"ID":"20250206195641-fjyvq1r","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-fjyvq1r","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003cbits/stdc++.h\u003e\n#include\u003cstring\u003e\nusing namespace std;\nconst int N=1e6+10;\nint head,e[N],ne[N],idx;\n\nvoid init()//链表的初始化\n{\n    head=-1;\n    idx=0;\n}\n\nvoid add_head(int x)//向头节点之后插入一个数\n{\n    e[idx]=x,ne[idx]=head,head=idx++;\n}\n\nvoid add(int k,int x)//向第k个插入的数后面插入一个数\n{\n    e[idx]=x,ne[idx]=ne[k],ne[k]=idx++;\n}\n\nvoid de(int k)//删除第k个插入的数\n{\n    ne[k]=ne[ne[k]];\n}\n\nvoid remove()//删除头节点\n{\n    head=ne[head];\n}\n\nint main()\n{\n    int t;\n    scanf(\"%d\",\u0026t);\n    init();\n    while(t--){\n        string op;\n        int k,x;\n        cin\u003e\u003eop;\n        if(op==\"H\"){\n            scanf(\"%d\",\u0026x);\n            add_head(x);\n        }\n        else if(op==\"D\"){\n            scanf(\"%d\",\u0026k);\n            if(k==0) remove();\n            de(k-1);\n        }\n        else{\n            scanf(\"%d%d\",\u0026k,\u0026x);\n            add(k-1,x);\n        }\n    }\n    for(int i=head;i!=-1;i=ne[i])\n        cout\u003c\u003ce[i]\u003c\u003c\" \";\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-cldoggj","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-cldoggj","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"双链表"}]},{"ID":"20250206195641-t4qyi8l","Type":"NodeParagraph","Properties":{"id":"20250206195641-t4qyi8l","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"实现一个双链表，双链表初始为空，支持 55 种操作："}]},{"ID":"20250206195641-20qn0af","Type":"NodeParagraph","Properties":{"id":"20250206195641-20qn0af","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"在最左侧插入一个数；"}]},{"ID":"20250206195641-yn3z8wy","Type":"NodeParagraph","Properties":{"id":"20250206195641-yn3z8wy","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"在最右侧插入一个数；"}]},{"ID":"20250206195641-o29ifua","Type":"NodeParagraph","Properties":{"id":"20250206195641-o29ifua","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"将第 k 个插入的数删除；"}]},{"ID":"20250206195641-jcfxxby","Type":"NodeParagraph","Properties":{"id":"20250206195641-jcfxxby","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"在第 k 个插入的数左侧插入一个数；"}]},{"ID":"20250206195641-22asrr4","Type":"NodeParagraph","Properties":{"id":"20250206195641-22asrr4","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"在第 k 个插入的数右侧插入一个数"}]},{"ID":"20250206195641-dj6obdq","Type":"NodeParagraph","Properties":{"id":"20250206195641-dj6obdq","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"现在要对该链表进行 M 次操作，进行完所有操作后，从左到右输出整个链表。"}]},{"ID":"20250206195641-j0uoe3n","Type":"NodeParagraph","Properties":{"id":"20250206195641-j0uoe3n","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"注意:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。"}]},{"ID":"20250206195641-4c6cth1","Type":"NodeParagraph","Properties":{"id":"20250206195641-4c6cth1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-ygpff5z","Type":"NodeParagraph","Properties":{"id":"20250206195641-ygpff5z","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含整数 M，表示操作次数。"}]},{"ID":"20250206195641-32j4udm","Type":"NodeParagraph","Properties":{"id":"20250206195641-32j4udm","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"接下来 M 行，每行包含一个操作命令，操作命令可能为以下几种："}]},{"ID":"20250206195641-v51q844","Type":"NodeParagraph","Properties":{"id":"20250206195641-v51q844","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"L x，表示在链表的最左端插入数 x。"}]},{"ID":"20250206195641-pwxkbcc","Type":"NodeParagraph","Properties":{"id":"20250206195641-pwxkbcc","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"R x，表示在链表的最右端插入数 x。"}]},{"ID":"20250206195641-ftr4fl9","Type":"NodeParagraph","Properties":{"id":"20250206195641-ftr4fl9","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"D k，表示将第 k 个插入的数删除。"}]},{"ID":"20250206195641-tiuarqv","Type":"NodeParagraph","Properties":{"id":"20250206195641-tiuarqv","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"IL k x，表示在第 k 个插入的数左侧插入一个数。"}]},{"ID":"20250206195641-xgxwqlp","Type":"NodeParagraph","Properties":{"id":"20250206195641-xgxwqlp","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"IR k x，表示在第 k 个插入的数右侧插入一个数。"}]},{"ID":"20250206195641-7pddadw","Type":"NodeParagraph","Properties":{"id":"20250206195641-7pddadw","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-n98479y","Type":"NodeParagraph","Properties":{"id":"20250206195641-n98479y","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"共一行，将整个链表从左到右输出。"}]},{"ID":"20250206195641-i0xn8iu","Type":"NodeParagraph","Properties":{"id":"20250206195641-i0xn8iu","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-4xpf71f","Type":"NodeParagraph","Properties":{"id":"20250206195641-4xpf71f","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤M≤100000"}]},{"ID":"20250206195641-1gl10pz","Type":"NodeParagraph","Properties":{"id":"20250206195641-1gl10pz","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"所有操作保证合法。"}]},{"ID":"20250206195641-z25jm9d","Type":"NodeParagraph","Properties":{"id":"20250206195641-z25jm9d","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-6vbx3ys","Type":"NodeParagraph","Properties":{"id":"20250206195641-6vbx3ys","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"10"}]},{"ID":"20250206195641-y87fvag","Type":"NodeParagraph","Properties":{"id":"20250206195641-y87fvag","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"R 7"}]},{"ID":"20250206195641-5ypelxf","Type":"NodeParagraph","Properties":{"id":"20250206195641-5ypelxf","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"D 1"}]},{"ID":"20250206195641-jc70egg","Type":"NodeParagraph","Properties":{"id":"20250206195641-jc70egg","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"L 3"}]},{"ID":"20250206195641-09ha0ea","Type":"NodeParagraph","Properties":{"id":"20250206195641-09ha0ea","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"IL 2 10"}]},{"ID":"20250206195641-4k5uvy2","Type":"NodeParagraph","Properties":{"id":"20250206195641-4k5uvy2","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"D 3"}]},{"ID":"20250206195641-kiw2mbk","Type":"NodeParagraph","Properties":{"id":"20250206195641-kiw2mbk","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"IL 2 7"}]},{"ID":"20250206195641-0z72cbp","Type":"NodeParagraph","Properties":{"id":"20250206195641-0z72cbp","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"L 8"}]},{"ID":"20250206195641-7s4m0m8","Type":"NodeParagraph","Properties":{"id":"20250206195641-7s4m0m8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"R 9"}]},{"ID":"20250206195641-7tzq0dd","Type":"NodeParagraph","Properties":{"id":"20250206195641-7tzq0dd","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"IL 4 7"}]},{"ID":"20250206195641-jp3sdjq","Type":"NodeParagraph","Properties":{"id":"20250206195641-jp3sdjq","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"IR 2 2"}]},{"ID":"20250206195641-wqqgf93","Type":"NodeParagraph","Properties":{"id":"20250206195641-wqqgf93","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-k5r9t17","Type":"NodeParagraph","Properties":{"id":"20250206195641-k5r9t17","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"8 7 7 3 2 9"}]},{"ID":"20250206195641-ors3rrm","Type":"NodeParagraph","Properties":{"id":"20250206195641-ors3rrm","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"双链表类似单链表的操作进行处理，只是每个节点都有两个指针l[],r[],分别指向前驱和后继。"}]},{"ID":"20250206195641-58fzdhj","Type":"NodeParagraph","Properties":{"id":"20250206195641-58fzdhj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"模板："}]},{"ID":"20250206195641-aqrdl89","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-aqrdl89","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点\nint e[N], l[N], r[N], idx;\n\n// 初始化\nvoid init()\n{\n    //0是左端点，1是右端点\n    r[0] = 1, l[1] = 0;\n    idx = 2;\n}\n\n// 在节点a的右边插入一个数x\nvoid insert(int a, int x)\n{\n    e[idx] = x;\n    l[idx] = a, r[idx] = r[a];\n    l[r[a]] = idx, r[a] = idx ++ ;\n}\n\n// 删除节点a\nvoid remove(int a)\n{\n    l[r[a]] = l[a];\n    r[l[a]] = r[a];\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-3wl71c5","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-3wl71c5","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003cbits/stdc++.h\u003e\n#include\u003cstring\u003e\n#include\u003calgorithm\u003e\nusing namespace std;\nconst int N=1e6+10;\nint l[N],r[N],e[N],idx;\nvoid init()\n{\n    r[0]=1;\n    l[1]=0;\n    idx=2;\n}\n\nvoid add(int k,int x)\n{\n    e[idx]=x;\n    r[idx]=r[k];\n    l[idx]=k;\n    l[r[k]]=idx;\n    r[k]=idx;\n    idx++;\n}\n\nvoid remove(int k)\n{\n    r[l[k]]=r[k];\n    l[r[k]]=l[k];\n}\nint main()\n{\n    init();\n    int t;\n    cin\u003e\u003et;\n    while(t--)\n    {\n        string op;\n        cin\u003e\u003eop;\n        int k,x;\n        if(op==\"R\")\n        {\n            cin\u003e\u003ex;\n            add(l[1],x);\n        }\n        else if(op==\"L\")\n        {\n            cin\u003e\u003ex;\n            add(0,x);\n        }\n        else if(op==\"D\")\n        {\n            cin\u003e\u003ek;\n            remove(k+1);\n        }\n        else if(op==\"IL\")\n        {\n            cin\u003e\u003ek\u003e\u003ex;\n            add(l[k+1],x);\n        }\n        else\n        {\n            cin\u003e\u003ek\u003e\u003ex;\n            add(k+1,x);\n        }\n    }\n    for(int i=r[0];i!=1;i=r[i])\n        cout\u003c\u003ce[i]\u003c\u003c\" \";\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-0lmynfg","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-0lmynfg","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"栈"}]},{"ID":"20250206195641-srkfueq","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-srkfueq","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"模拟栈"}]},{"ID":"20250206195641-5jten37","Type":"NodeParagraph","Properties":{"id":"20250206195641-5jten37","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"实现一个栈，栈初始为空，支持四种操作："}]},{"ID":"20250206195641-w4lpk78","Type":"NodeParagraph","Properties":{"id":"20250206195641-w4lpk78","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"push x – 向栈顶插入一个数 x；"}]},{"ID":"20250206195641-2t7o9jc","Type":"NodeParagraph","Properties":{"id":"20250206195641-2t7o9jc","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"pop – 从栈顶弹出一个数；"}]},{"ID":"20250206195641-eglc603","Type":"NodeParagraph","Properties":{"id":"20250206195641-eglc603","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"empty – 判断栈是否为空；"}]},{"ID":"20250206195641-xhfpa6o","Type":"NodeParagraph","Properties":{"id":"20250206195641-xhfpa6o","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"query – 查询栈顶元素。"}]},{"ID":"20250206195641-mw6h4ik","Type":"NodeParagraph","Properties":{"id":"20250206195641-mw6h4ik","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"现在要对栈进行 M 个操作，其中的每个操作 3 和操作 4 都要输出相应的结果。"}]},{"ID":"20250206195641-m5q2rzq","Type":"NodeParagraph","Properties":{"id":"20250206195641-m5q2rzq","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-zv2p84q","Type":"NodeParagraph","Properties":{"id":"20250206195641-zv2p84q","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含整数 M，表示操作次数。"}]},{"ID":"20250206195641-zksy3ar","Type":"NodeParagraph","Properties":{"id":"20250206195641-zksy3ar","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"接下来 M 行，每行包含一个操作命令，操作命令为 push x，pop，empty，query 中的一种。"}]},{"ID":"20250206195641-hq4001m","Type":"NodeParagraph","Properties":{"id":"20250206195641-hq4001m","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-q7iple0","Type":"NodeParagraph","Properties":{"id":"20250206195641-q7iple0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。"}]},{"ID":"20250206195641-tgydzk7","Type":"NodeParagraph","Properties":{"id":"20250206195641-tgydzk7","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示栈顶元素的值。"}]},{"ID":"20250206195641-ivwas1b","Type":"NodeParagraph","Properties":{"id":"20250206195641-ivwas1b","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-krdvzjl","Type":"NodeParagraph","Properties":{"id":"20250206195641-krdvzjl","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤M≤100000,"}]},{"ID":"20250206195641-imo2t3l","Type":"NodeParagraph","Properties":{"id":"20250206195641-imo2t3l","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤x≤1e9"}]},{"ID":"20250206195641-aoomdzp","Type":"NodeParagraph","Properties":{"id":"20250206195641-aoomdzp","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"所有操作保证合法。"}]},{"ID":"20250206195641-1la3xy0","Type":"NodeParagraph","Properties":{"id":"20250206195641-1la3xy0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-zbltial","Type":"NodeParagraph","Properties":{"id":"20250206195641-zbltial","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"10"}]},{"ID":"20250206195641-lyr1ige","Type":"NodeParagraph","Properties":{"id":"20250206195641-lyr1ige","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"push 5"}]},{"ID":"20250206195641-ml26tjy","Type":"NodeParagraph","Properties":{"id":"20250206195641-ml26tjy","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"query"}]},{"ID":"20250206195641-9xxf4dg","Type":"NodeParagraph","Properties":{"id":"20250206195641-9xxf4dg","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"push 6"}]},{"ID":"20250206195641-f4u2h3n","Type":"NodeParagraph","Properties":{"id":"20250206195641-f4u2h3n","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"pop"}]},{"ID":"20250206195641-q3nh0ed","Type":"NodeParagraph","Properties":{"id":"20250206195641-q3nh0ed","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"query"}]},{"ID":"20250206195641-zc3gb86","Type":"NodeParagraph","Properties":{"id":"20250206195641-zc3gb86","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"pop"}]},{"ID":"20250206195641-14yidvi","Type":"NodeParagraph","Properties":{"id":"20250206195641-14yidvi","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"empty"}]},{"ID":"20250206195641-avx8xyo","Type":"NodeParagraph","Properties":{"id":"20250206195641-avx8xyo","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"push 4"}]},{"ID":"20250206195641-8y3xeeq","Type":"NodeParagraph","Properties":{"id":"20250206195641-8y3xeeq","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"query"}]},{"ID":"20250206195641-duivmyx","Type":"NodeParagraph","Properties":{"id":"20250206195641-duivmyx","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"empty"}]},{"ID":"20250206195641-i1c2u7z","Type":"NodeParagraph","Properties":{"id":"20250206195641-i1c2u7z","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-8dgdw7h","Type":"NodeParagraph","Properties":{"id":"20250206195641-8dgdw7h","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"5"}]},{"ID":"20250206195641-teakqvk","Type":"NodeParagraph","Properties":{"id":"20250206195641-teakqvk","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"5"}]},{"ID":"20250206195641-hcevh16","Type":"NodeParagraph","Properties":{"id":"20250206195641-hcevh16","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"YES"}]},{"ID":"20250206195641-skoe6ds","Type":"NodeParagraph","Properties":{"id":"20250206195641-skoe6ds","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"4"}]},{"ID":"20250206195641-rzoggg6","Type":"NodeParagraph","Properties":{"id":"20250206195641-rzoggg6","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"NO"}]},{"ID":"20250206195641-ycvhakz","Type":"NodeParagraph","Properties":{"id":"20250206195641-ycvhakz","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"栈：后进先出的数据结构。"}]},{"ID":"20250206195641-jd55cox","Type":"NodeParagraph","Properties":{"id":"20250206195641-jd55cox","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/0fd62bbd7db86b69886a6d42ea970af8.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-g437m99","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-g437m99","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"// tt表示栈顶\nint stk[N], tt = 0;\n\n// 向栈顶插入一个数\nstk[ ++ tt] = x;\n\n// 从栈顶弹出一个数\ntt -- ;\n\n// 栈顶的值\nstk[tt];\n\n// 判断栈是否为空\nif (tt \u003e 0)\n{\n\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-6thzns9","Type":"NodeParagraph","Properties":{"id":"20250206195641-6thzns9","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"AC代码"}]},{"ID":"20250206195641-qbkresu","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-qbkresu","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003cbits/stdc++.h\u003e\nusing namespace std;\nconst int N=1e6+10;\nint stk[N],tt=0;\nint main()\n{\n    int t;\n    cin\u003e\u003et;\n    while(t--)\n    {\n        string op;\n        cin\u003e\u003eop;\n        if(op==\"push\")\n        {\n            int x;\n            cin\u003e\u003ex;\n            stk[++tt]=x;\n        }\n        else if(op==\"pop\")\n        {\n            tt--;\n        }\n        else if(op==\"empty\")\n        {\n            if(tt\u003e0)\n            cout\u003c\u003c\"NO\"\u003c\u003cendl;\n            else\n            cout\u003c\u003c\"YES\"\u003c\u003cendl;\n        }\n        else if(op==\"query\")\n        {\n            cout\u003c\u003cstk[tt]\u003c\u003cendl;\n        }\n    }\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-4fayqs7","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-4fayqs7","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"队列"}]},{"ID":"20250206195641-l98ugn9","Type":"NodeParagraph","Properties":{"id":"20250206195641-l98ugn9","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"实现一个队列，队列初始为空，支持四种操作："}]},{"ID":"20250206195641-9nrqu68","Type":"NodeParagraph","Properties":{"id":"20250206195641-9nrqu68","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"push x – 向队尾插入一个数 x；"}]},{"ID":"20250206195641-aptrlch","Type":"NodeParagraph","Properties":{"id":"20250206195641-aptrlch","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"pop – 从队头弹出一个数；"}]},{"ID":"20250206195641-qs52grx","Type":"NodeParagraph","Properties":{"id":"20250206195641-qs52grx","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"empty – 判断队列是否为空；"}]},{"ID":"20250206195641-aynol1b","Type":"NodeParagraph","Properties":{"id":"20250206195641-aynol1b","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"query – 查询队头元素。"}]},{"ID":"20250206195641-5jwp1z1","Type":"NodeParagraph","Properties":{"id":"20250206195641-5jwp1z1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"现在要对队列进行 M个操作，其中的每个操作 3和操作 4 都要输出相应的结果。"}]},{"ID":"20250206195641-gza40ww","Type":"NodeParagraph","Properties":{"id":"20250206195641-gza40ww","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-fyje9fk","Type":"NodeParagraph","Properties":{"id":"20250206195641-fyje9fk","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含整数 M，表示操作次数。"}]},{"ID":"20250206195641-bwin5gf","Type":"NodeParagraph","Properties":{"id":"20250206195641-bwin5gf","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"接下来 M行，每行包含一个操作命令，操作命令为 push x，pop，empty，query 中的一种。"}]},{"ID":"20250206195641-5goq24i","Type":"NodeParagraph","Properties":{"id":"20250206195641-5goq24i","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-e41eocf","Type":"NodeParagraph","Properties":{"id":"20250206195641-e41eocf","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"对于每个 empty 和 query 操作都要输出一个查询结果，每个结果占一行。"}]},{"ID":"20250206195641-zdu8n4l","Type":"NodeParagraph","Properties":{"id":"20250206195641-zdu8n4l","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"其中，empty 操作的查询结果为 YES 或 NO，query 操作的查询结果为一个整数，表示队头元素的值。"}]},{"ID":"20250206195641-w6fefts","Type":"NodeParagraph","Properties":{"id":"20250206195641-w6fefts","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-218b6yo","Type":"NodeParagraph","Properties":{"id":"20250206195641-218b6yo","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤M≤100000,"}]},{"ID":"20250206195641-668u43w","Type":"NodeParagraph","Properties":{"id":"20250206195641-668u43w","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤x≤1e9,"}]},{"ID":"20250206195641-xqvem8t","Type":"NodeParagraph","Properties":{"id":"20250206195641-xqvem8t","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"所有操作保证合法。"}]},{"ID":"20250206195641-855wbch","Type":"NodeParagraph","Properties":{"id":"20250206195641-855wbch","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-dv6vtcg","Type":"NodeParagraph","Properties":{"id":"20250206195641-dv6vtcg","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"10"}]},{"ID":"20250206195641-9b3ob5x","Type":"NodeParagraph","Properties":{"id":"20250206195641-9b3ob5x","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"push 6"}]},{"ID":"20250206195641-q7ir4w5","Type":"NodeParagraph","Properties":{"id":"20250206195641-q7ir4w5","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"empty"}]},{"ID":"20250206195641-z4bjjqt","Type":"NodeParagraph","Properties":{"id":"20250206195641-z4bjjqt","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"query"}]},{"ID":"20250206195641-tqk9frs","Type":"NodeParagraph","Properties":{"id":"20250206195641-tqk9frs","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"pop"}]},{"ID":"20250206195641-3fjkd16","Type":"NodeParagraph","Properties":{"id":"20250206195641-3fjkd16","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"empty"}]},{"ID":"20250206195641-0fbh2k8","Type":"NodeParagraph","Properties":{"id":"20250206195641-0fbh2k8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"push 3"}]},{"ID":"20250206195641-dpvxysr","Type":"NodeParagraph","Properties":{"id":"20250206195641-dpvxysr","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"push 4"}]},{"ID":"20250206195641-njg5z6w","Type":"NodeParagraph","Properties":{"id":"20250206195641-njg5z6w","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"pop"}]},{"ID":"20250206195641-omoac3p","Type":"NodeParagraph","Properties":{"id":"20250206195641-omoac3p","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"query"}]},{"ID":"20250206195641-ub4iy4l","Type":"NodeParagraph","Properties":{"id":"20250206195641-ub4iy4l","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"push 6"}]},{"ID":"20250206195641-qhphvcv","Type":"NodeParagraph","Properties":{"id":"20250206195641-qhphvcv","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-qzvkw78","Type":"NodeParagraph","Properties":{"id":"20250206195641-qzvkw78","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"NO"}]},{"ID":"20250206195641-xh6imq9","Type":"NodeParagraph","Properties":{"id":"20250206195641-xh6imq9","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"6"}]},{"ID":"20250206195641-pq80tjr","Type":"NodeParagraph","Properties":{"id":"20250206195641-pq80tjr","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"YES"}]},{"ID":"20250206195641-ygv0hqg","Type":"NodeParagraph","Properties":{"id":"20250206195641-ygv0hqg","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"4"}]},{"ID":"20250206195641-adgljun","Type":"NodeParagraph","Properties":{"id":"20250206195641-adgljun","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"队列:先进先出。"}]},{"ID":"20250206195641-llynnu2","Type":"NodeParagraph","Properties":{"id":"20250206195641-llynnu2","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"普通队列"}]},{"ID":"20250206195641-tw68hnr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-tw68hnr","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"// hh 表示队头，tt表示队尾\nint q[N], hh = 0, tt = -1;\n\n// 向队尾插入一个数\nq[ ++ tt] = x;\n\n// 从队头弹出一个数\nhh ++ ;\n\n// 队头的值\nq[hh];\n\n// 判断队列是否为空\nif (hh \u003c= tt)\n{\n\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-0mncl69","Type":"NodeParagraph","Properties":{"id":"20250206195641-0mncl69","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"循环队列"}]},{"ID":"20250206195641-grbbi2q","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-grbbi2q","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"// hh 表示队头，tt表示队尾的后一个位置\nint q[N], hh = 0, tt = 0;\n\n// 向队尾插入一个数\nq[tt ++ ] = x;\nif (tt == N) tt = 0;\n\n// 从队头弹出一个数\nhh ++ ;\nif (hh == N) hh = 0;\n\n// 队头的值\nq[hh];\n\n// 判断队列是否为空\nif (hh != tt)\n{\n\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-yetn7f3","Type":"NodeParagraph","Properties":{"id":"20250206195641-yetn7f3","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"AC代码"}]},{"ID":"20250206195641-hwdapd4","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-hwdapd4","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003cbits/stdc++.h\u003e\nusing namespace std;\nconst int N=1e6+10;\nint q[N],hh=0,tt=-1;\nint main()\n{\n    ios::sync_with_stdio(false);\n    int T;\n    cin\u003e\u003eT;\n    while(T--){\n        string op;\n        cin\u003e\u003eop;\n        if(op==\"push\"){\n            int x;\n            cin\u003e\u003ex;\n            q[++tt]=x;\n        }\n        else if(op==\"pop\"){\n            hh++;\n        }\n        else if(op==\"empty\"){\n            if(hh\u003c=tt) cout\u003c\u003c\"NO\"\u003c\u003cendl;\n            else cout\u003c\u003c\"YES\"\u003c\u003cendl;\n        }\n        else cout\u003c\u003cq[hh]\u003c\u003cendl;\n    }\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-7mairlq","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-7mairlq","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"单调队列"}]},{"ID":"20250206195641-8irpyng","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-8irpyng","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"滑动窗口"}]},{"ID":"20250206195641-wip9psu","Type":"NodeParagraph","Properties":{"id":"20250206195641-wip9psu","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"给定一个大小为 n≤1e6的数组。"}]},{"ID":"20250206195641-she2kux","Type":"NodeParagraph","Properties":{"id":"20250206195641-she2kux","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"有一个大小为 k的滑动窗口，它从数组的最左边移动到最右边。"}]},{"ID":"20250206195641-hx4rcpt","Type":"NodeParagraph","Properties":{"id":"20250206195641-hx4rcpt","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"你只能在窗口中看到 kk 个数字。"}]},{"ID":"20250206195641-83op6vd","Type":"NodeParagraph","Properties":{"id":"20250206195641-83op6vd","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"每次滑动窗口向右移动一个位置。"}]},{"ID":"20250206195641-6jkjpat","Type":"NodeParagraph","Properties":{"id":"20250206195641-6jkjpat","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"以下是一个例子："}]},{"ID":"20250206195641-agwx2jp","Type":"NodeParagraph","Properties":{"id":"20250206195641-agwx2jp","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"该数组为 [1 3 -1 -3 5 3 6 7]，k 为 3。"}]},{"ID":"20250206195641-wweohwh","Type":"NodeParagraph","Properties":{"id":"20250206195641-wweohwh","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/93bd904a2cce9648d7f1be09d215df1d.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-bi136hm","Type":"NodeParagraph","Properties":{"id":"20250206195641-bi136hm","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。"}]},{"ID":"20250206195641-bv6fgr9","Type":"NodeParagraph","Properties":{"id":"20250206195641-bv6fgr9","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-i1vq95v","Type":"NodeParagraph","Properties":{"id":"20250206195641-i1vq95v","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入包含两行。"}]},{"ID":"20250206195641-zo2kxqj","Type":"NodeParagraph","Properties":{"id":"20250206195641-zo2kxqj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。"}]},{"ID":"20250206195641-nep019x","Type":"NodeParagraph","Properties":{"id":"20250206195641-nep019x","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第二行有 n个整数，代表数组的具体数值。"}]},{"ID":"20250206195641-pma9jxk","Type":"NodeParagraph","Properties":{"id":"20250206195641-pma9jxk","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"同行数据之间用空格隔开。"}]},{"ID":"20250206195641-7tzc8je","Type":"NodeParagraph","Properties":{"id":"20250206195641-7tzc8je","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-n2c359e","Type":"NodeParagraph","Properties":{"id":"20250206195641-n2c359e","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出包含两个。"}]},{"ID":"20250206195641-i7vtio4","Type":"NodeParagraph","Properties":{"id":"20250206195641-i7vtio4","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行输出，从左至右，每个位置滑动窗口中的最小值。"}]},{"ID":"20250206195641-vrn1hlq","Type":"NodeParagraph","Properties":{"id":"20250206195641-vrn1hlq","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第二行输出，从左至右，每个位置滑动窗口中的最大值。"}]},{"ID":"20250206195641-2kuqlhr","Type":"NodeParagraph","Properties":{"id":"20250206195641-2kuqlhr","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-wr9i705","Type":"NodeParagraph","Properties":{"id":"20250206195641-wr9i705","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"8 3"}]},{"ID":"20250206195641-xo3u4i0","Type":"NodeParagraph","Properties":{"id":"20250206195641-xo3u4i0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1 3 -1 -3 5 3 6 7"}]},{"ID":"20250206195641-vrfmyr0","Type":"NodeParagraph","Properties":{"id":"20250206195641-vrfmyr0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-eiymoys","Type":"NodeParagraph","Properties":{"id":"20250206195641-eiymoys","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"-1 -3 -3 -3 3 3"}]},{"ID":"20250206195641-f255bi1","Type":"NodeParagraph","Properties":{"id":"20250206195641-f255bi1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"3 3 5 5 6 7"}]},{"ID":"20250206195641-muxxxwg","Type":"NodeParagraph","Properties":{"id":"20250206195641-muxxxwg","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"性质：队列里面的元素值是单调的，递增或者递减。"}]},{"ID":"20250206195641-m737m3o","Type":"NodeParagraph","Properties":{"id":"20250206195641-m737m3o","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"思想："}]},{"ID":"20250206195641-dm01ihp","Type":"NodeParagraph","Properties":{"id":"20250206195641-dm01ihp","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"例如：求滑动窗口的最大值。"}]},{"ID":"20250206195641-bsjeqoi","Type":"NodeParagraph","Properties":{"id":"20250206195641-bsjeqoi","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"用单调队列储存当前窗口内单调递减的元素的下标，并且队头是窗口内的最大值，队尾是窗口内的尾元素。也就是说，队列从队头到队尾对应窗口内从最大值到窗口的尾元素的子序列下标。"}]},{"ID":"20250206195641-r4w2pwr","Type":"NodeParagraph","Properties":{"id":"20250206195641-r4w2pwr","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1.队头出队：当队头元素从滑动窗口划出时，队头元素出队，hh++。"}]},{"ID":"20250206195641-jx9eqbm","Type":"NodeParagraph","Properties":{"id":"20250206195641-jx9eqbm","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2.队尾出队：当新的元素进入滑动窗口时，要把新元素从队尾插入，分两种情况："}]},{"ID":"20250206195641-34z25qh","Type":"NodeParagraph","Properties":{"id":"20250206195641-34z25qh","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(1).直接插入：如果新元素小于队尾元素，那么直接从队尾插入(q[++tt]"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"i)，因为他可能在前面的最大值滑出窗口后成为最大值。"}]},{"ID":"20250206195641-xskpysb","Type":"NodeParagraph","Properties":{"id":"20250206195641-xskpysb","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(2).先删后插:如果新元素大于等于队尾元素，那就先删除队尾元素(因为队尾不可能成为滑动窗口的最大值），删除队尾tt--,循环删除，直到队列为空或遇到一个大于新元素的值，再插入。"}]},{"ID":"20250206195641-e9ir4xn","Type":"NodeParagraph","Properties":{"id":"20250206195641-e9ir4xn","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/cfa71fa26d17e94f07ccf89e2a394efd.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-hxid5wz","Type":"NodeParagraph","Properties":{"id":"20250206195641-hxid5wz","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"求最小值的思路相同。"}]},{"ID":"20250206195641-ivo9q5d","Type":"NodeParagraph","Properties":{"id":"20250206195641-ivo9q5d","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"AC代码"}]},{"ID":"20250206195641-2aeo5la","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-2aeo5la","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\nusing namespace std;\nconst int N = 1e6+10;\nint a[N],q[N];\nint n,k;\nint main()\n{\n    int n,k;\n    cin\u003e\u003en\u003e\u003ek;\n    for(int i=1;i\u003c=n;i++) cin\u003e\u003ea[i];\n\n    //求滑动窗口里面的最小值。\n    int hh=0,tt=-1;\n    for(int i=1;i\u003c=n;i++)\n    {\n        if(hh\u003c=tt\u0026\u0026q[hh]\u003ci-k+1) hh++; //如果队头元素值表示序列的下表不在滑动窗口的范围内，队头出队。\n        while(hh\u003c=tt\u0026\u0026a[i]\u003c=a[q[tt]]) tt--; //如果插入的元素小于队尾元素，队尾出队，直到不小于为止。\n        q[++tt]=i; //下表入队\n        if(i\u003ek-1) cout\u003c\u003ca[q[hh]]\u003c\u003c\" \"; //如果在滑动窗口的范围，输出最小值即可。\n    }\n    puts(\"\");\n\n    //求滑动窗口里面的最大值\n    hh=0,tt=-1;\n    for(int i=1;i\u003c=n;i++)\n    {\n        if(hh\u003c=tt\u0026\u0026q[hh]\u003ci-k+1) hh++;\n        while(hh\u003c=tt\u0026\u0026a[i]\u003e=a[q[tt]]) tt--;\n        q[++tt]=i;\n        if(i\u003ek-1) cout\u003c\u003ca[q[hh]]\u003c\u003c\" \";\n    }\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-e49pyn6","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-e49pyn6","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"单调队列stl实现"}]},{"ID":"20250206195641-mh1hlvv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-mh1hlvv","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003cdeque\u003e\n#include \u003cvector\u003e\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin \u003e\u003e n \u003e\u003e k;\n    vector\u003cint\u003e a(n);\n    for (int i = 0; i \u003c n; i++) {\n        cin \u003e\u003e a[i];\n    }\n\n    // 求滑动窗口最小值\n    deque\u003cint\u003e dqMin; // 存放下标，保证对应的 a 值单调递增\n    for (int i = 0; i \u003c n; i++) {\n        // 移除不在窗口中的下标\n        if (!dqMin.empty() \u0026\u0026 dqMin.front() \u003c= i - k)\n            dqMin.pop_front();\n        // 移除所有比当前数 a[i] 大的下标\n        while (!dqMin.empty() \u0026\u0026 a[i] \u003c= a[dqMin.back()])\n            dqMin.pop_back();\n        dqMin.push_back(i);\n        if (i \u003e= k - 1)\n            cout \u003c\u003c a[dqMin.front()] \u003c\u003c \" \";\n    }\n    cout \u003c\u003c \"\\n\";\n\n    // 求滑动窗口最大值\n    deque\u003cint\u003e dqMax; // 存放下标，保证对应的 a 值单调递减\n    for (int i = 0; i \u003c n; i++) {\n        // 移除不在窗口中的下标\n        if (!dqMax.empty() \u0026\u0026 dqMax.front() \u003c= i - k)\n            dqMax.pop_front();\n        // 移除所有比当前数 a[i] 小的下标\n        while (!dqMax.empty() \u0026\u0026 a[i] \u003e= a[dqMax.back()])\n            dqMax.pop_back();\n        dqMax.push_back(i);\n        if (i \u003e= k - 1)\n            cout \u003c\u003c a[dqMax.front()] \u003c\u003c \" \";\n    }\n    cout \u003c\u003c \"\\n\";\n\n    return 0;\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-l6n1a3v","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-l6n1a3v","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"KMP"}]},{"ID":"20250206195641-34xvasz","Type":"NodeParagraph","Properties":{"id":"20250206195641-34xvasz","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"给定一个字符串 S，以及一个模式串 P，所有字符串中只包含大小写英文字母以及阿拉伯数字。"}]},{"ID":"20250206195641-ypqjvhx","Type":"NodeParagraph","Properties":{"id":"20250206195641-ypqjvhx","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"模式串 P在字符串 S中多次作为子串出现。"}]},{"ID":"20250206195641-3dhgn1r","Type":"NodeParagraph","Properties":{"id":"20250206195641-3dhgn1r","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"求出模式串 P在字符串 S中所有出现的位置的起始下标。"}]},{"ID":"20250206195641-buhqb2t","Type":"NodeParagraph","Properties":{"id":"20250206195641-buhqb2t","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-fthomcv","Type":"NodeParagraph","Properties":{"id":"20250206195641-fthomcv","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行输入整数 N，表示字符串 P 的长度。"}]},{"ID":"20250206195641-xgp2q5f","Type":"NodeParagraph","Properties":{"id":"20250206195641-xgp2q5f","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第二行输入字符串 P。"}]},{"ID":"20250206195641-aldwgu5","Type":"NodeParagraph","Properties":{"id":"20250206195641-aldwgu5","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第三行输入整数 M，表示字符串 S的长度。"}]},{"ID":"20250206195641-uw0hgwu","Type":"NodeParagraph","Properties":{"id":"20250206195641-uw0hgwu","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第四行输入字符串 S。"}]},{"ID":"20250206195641-9fl0lxh","Type":"NodeParagraph","Properties":{"id":"20250206195641-9fl0lxh","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-udyho8r","Type":"NodeParagraph","Properties":{"id":"20250206195641-udyho8r","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"共一行，输出所有出现位置的起始下标（下标从 0开始计数），整数之间用空格隔开。"}]},{"ID":"20250206195641-dt28d6z","Type":"NodeParagraph","Properties":{"id":"20250206195641-dt28d6z","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-tiucym8","Type":"NodeParagraph","Properties":{"id":"20250206195641-tiucym8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤N≤1e5"}]},{"ID":"20250206195641-ptxp8fm","Type":"NodeParagraph","Properties":{"id":"20250206195641-ptxp8fm","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤M≤1e6"}]},{"ID":"20250206195641-6h1v6jo","Type":"NodeParagraph","Properties":{"id":"20250206195641-6h1v6jo","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-xyexjkh","Type":"NodeParagraph","Properties":{"id":"20250206195641-xyexjkh","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"3"}]},{"ID":"20250206195641-wv8ar41","Type":"NodeParagraph","Properties":{"id":"20250206195641-wv8ar41","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"aba"}]},{"ID":"20250206195641-cn4n6sy","Type":"NodeParagraph","Properties":{"id":"20250206195641-cn4n6sy","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"5"}]},{"ID":"20250206195641-mb1jnbu","Type":"NodeParagraph","Properties":{"id":"20250206195641-mb1jnbu","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"ababa"}]},{"ID":"20250206195641-2j7kwk4","Type":"NodeParagraph","Properties":{"id":"20250206195641-2j7kwk4","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-hcfh6tc","Type":"NodeParagraph","Properties":{"id":"20250206195641-hcfh6tc","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"0 2"}]},{"ID":"20250206195641-cpfiifc","Type":"NodeParagraph","Properties":{"id":"20250206195641-cpfiifc","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1.串的普通算法BF"}]},{"ID":"20250206195641-tspwkfh","Type":"NodeParagraph","Properties":{"id":"20250206195641-tspwkfh","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"BF算法图示过程(返回匹配成功的位置)"}]},{"ID":"20250206195641-fnb0odn","Type":"NodeParagraph","Properties":{"id":"20250206195641-fnb0odn","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/4cf810983a46bfd36e749ac3c58b7e30.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-r577y12","Type":"NodeParagraph","Properties":{"id":"20250206195641-r577y12","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"思想:"}]},{"ID":"20250206195641-zfw0jwi","Type":"NodeParagraph","Properties":{"id":"20250206195641-zfw0jwi","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"从主串的第pos个字符开始匹配和模式串中第一个字符串开始比较。"}]},{"ID":"20250206195641-w252qk2","Type":"NodeParagraph","Properties":{"id":"20250206195641-w252qk2","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(1)如果相等：继续比后续字符,i++,j++;"}]},{"ID":"20250206195641-2ju3dm0","Type":"NodeParagraph","Properties":{"id":"20250206195641-2ju3dm0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(2)如果不相等，从主串的下一个字符和模式串 的第一个字符相比较。"}]},{"ID":"20250206195641-thtbq7f","Type":"NodeParagraph","Properties":{"id":"20250206195641-thtbq7f","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"任何求主串的下一个字符的位置？"}]},{"ID":"20250206195641-232k85d","Type":"NodeParagraph","Properties":{"id":"20250206195641-232k85d","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"方法一：设置一个变量k，在主串未开始时，领k"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"i+1(主串的下一个位置),每当匹配失败，另i"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"j，即可。"}]},{"ID":"20250206195641-tnt62i7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-tnt62i7","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"int bf(char s[],char t[],int pos)\n{\n    int i=pos,j=1;//从主串的第pos个字符，和模式串第一个字符比较\n    while(i\u003c=s.length\u0026\u0026j\u003c=t.length)\n    {\n        int k=i+1; //让k等于i的下一个位置\n        if(s[i]==t[j]) //匹配成功，继续比较下一个位置\n        {\n            ++i;\n            ++j;\n        }\n        else //匹配失败\n        {\n            i=k;\n            j=1;\n        }\n    }\n    if(j\u003eT.length) return i-T.length;//如果j大于模式串的长度，说明匹配成功\n    else return 0; //匹配失败\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-5r7dkux","Type":"NodeParagraph","Properties":{"id":"20250206195641-5r7dkux","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"方法二：找出每次失败i和j的关系。"}]},{"ID":"20250206195641-yv88fml","Type":"NodeParagraph","Properties":{"id":"20250206195641-yv88fml","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/895aeec07513453916944506104dca5a.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-14736sf","Type":"NodeParagraph","Properties":{"id":"20250206195641-14736sf","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"则下一个位置是i-j+2."}]},{"ID":"20250206195641-we1n1g0","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-we1n1g0","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"int BF(char s[],char t[],int pos)\n{\n    int i=pos,j=1;\n    while(i\u003c=s.length\u0026\u0026j\u003ct.length)\n    {\n        if(s[i]==s[j]) \n        {\n            ++i;\n            ++j;\n        }\n        else\n        {\n            i=i-j+2;\n            j=1;\n        }\n    }\n    if(j\u003et.length) return i-t.length;\n    else return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-djdj110","Type":"NodeParagraph","Properties":{"id":"20250206195641-djdj110","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2.KMP算法"}]},{"ID":"20250206195641-yygrri0","Type":"NodeParagraph","Properties":{"id":"20250206195641-yygrri0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"特点：在匹配过程中，不需要回溯主串的指针i，时间复杂度为O(m+n)"}]},{"ID":"20250206195641-0vcncre","Type":"NodeParagraph","Properties":{"id":"20250206195641-0vcncre","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"思路："}]},{"ID":"20250206195641-y6dx1bb","Type":"NodeParagraph","Properties":{"id":"20250206195641-y6dx1bb","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/42771039e1b4490c3fb5901ef9929b95.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-0x6rs82","Type":"NodeParagraph","Properties":{"id":"20250206195641-0x6rs82","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"则我们可知next数组的含义，next[i]表示：以i结尾的后缀和从1开始模式串的前缀相等，且相等最大 。"}]},{"ID":"20250206195641-obksxsj","Type":"NodeParagraph","Properties":{"id":"20250206195641-obksxsj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"假设我们已知next数组，则模式匹配如下："}]},{"ID":"20250206195641-lggk8t8","Type":"NodeParagraph","Properties":{"id":"20250206195641-lggk8t8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/38273daedadafc0dd49549c065d3a423.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-sqa0g0u","Type":"NodeParagraph","Properties":{"id":"20250206195641-sqa0g0u","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"思想"}]},{"ID":"20250206195641-79pkt85","Type":"NodeParagraph","Properties":{"id":"20250206195641-79pkt85","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"主串的第pos个字符和模式串的第一个字符串进行比较"}]},{"ID":"20250206195641-9btkmis","Type":"NodeParagraph","Properties":{"id":"20250206195641-9btkmis","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(1).相等：继续比较后继字符 i++，j++。"}]},{"ID":"20250206195641-yhda79z","Type":"NodeParagraph","Properties":{"id":"20250206195641-yhda79z","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(2).不相等：主串的位置不变和模式串的第next[j]字符比较，j"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"next[j]。"}]},{"ID":"20250206195641-9zr19i7","Type":"NodeParagraph","Properties":{"id":"20250206195641-9zr19i7","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"下面展示一个代码："}]},{"ID":"20250206195641-ewgkb97","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-ewgkb97","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"int KMP(char s[],char t[],int pos)\n{\n    int i=pos,j=1;\n    while(i\u003c=s.length\u0026\u0026j\u003c=t.length)\n    {\n        if(j==0||s[i]==t[j]) //j==0表示当前比较的是模式串的首字符且不匹配，应从主串的后一个位置继续匹配；s[i]==t[j]表示匹配成功，继续匹配。\n        {\n            ++i;\n            ++j;\n        }\n        else j=next[j];\n    }\n    if(j\u003et.length) return i-t.length;\n    else return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-p3jb1wp","Type":"NodeParagraph","Properties":{"id":"20250206195641-p3jb1wp","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"求KMP的next指针的值"}]},{"ID":"20250206195641-ct2vbb0","Type":"NodeParagraph","Properties":{"id":"20250206195641-ct2vbb0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(1)如果t[j]"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"t[next[j]]，则next[j+1]"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"next[j]+1."}]},{"ID":"20250206195641-ttyrx57","Type":"NodeParagraph","Properties":{"id":"20250206195641-ttyrx57","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(2)如果t[j]!"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"t[next[j]],判断t[j]和t[next[...next[j]...]]，重复 过程（1），直到相等，退到0时，表示不存在，next[j+1]"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"1."}]},{"ID":"20250206195641-xb5w2uc","Type":"NodeParagraph","Properties":{"id":"20250206195641-xb5w2uc","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"换句话说，要求next[j]，需要判断t[j-1]和t[next[j-1]]."}]},{"ID":"20250206195641-0qzlreg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-0qzlreg","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"void get_next(char t[],int next[])\n{\n    int j=1,k=0;\n    next[1]=0;\n    while(j\u003ct.length)\n    {\n        if(k==0||t[j]==t[k])//k为0，或者找到时,next[j+1]=k。\n        {\n            ++j;\n            ++k;\n            next[j]=k;\n        }\n        else k=next[k];\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-0cdhqvx","Type":"NodeParagraph","Properties":{"id":"20250206195641-0cdhqvx","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"KMP的nextval值"}]},{"ID":"20250206195641-7nuyik4","Type":"NodeParagraph","Properties":{"id":"20250206195641-7nuyik4","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"思想："}]},{"ID":"20250206195641-yi0jnrn","Type":"NodeParagraph","Properties":{"id":"20250206195641-yi0jnrn","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"当s[i]和t[j]比较后，发现两者不相等时，但t[j]和t[k]相等，那就意味着s[i]和t[k]不需要进行额外的比较，因此j的位置的nextval值修改为k位置的nextval值，当s[i]和t[j]比较后，发现两者不相等，发现t[j]和t[k]也不相等，因此j位置的nextval值仍是k，即nextval[j]"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"next[j]."}]},{"ID":"20250206195641-hicaean","Type":"NodeParagraph","Properties":{"id":"20250206195641-hicaean","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"已知next[j]，应如下修改nextval值"}]},{"ID":"20250206195641-t4eqfsf","Type":"NodeParagraph","Properties":{"id":"20250206195641-t4eqfsf","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"k"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"next[j];"}]},{"ID":"20250206195641-eoeibsv","Type":"NodeParagraph","Properties":{"id":"20250206195641-eoeibsv","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"if(t[j]"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"t[k]) nextval[j]"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"next[k];"}]},{"ID":"20250206195641-3tetsz7","Type":"NodeParagraph","Properties":{"id":"20250206195641-3tetsz7","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"else nextval[j]"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"next[j];"}]},{"ID":"20250206195641-k02z78h","Type":"NodeParagraph","Properties":{"id":"20250206195641-k02z78h","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"例如：求aaaab的nextval值。"}]},{"ID":"20250206195641-pyxvnau","Type":"NodeParagraph","Properties":{"id":"20250206195641-pyxvnau","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"如果t[j]"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"t[next[j]],nextval[j]"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"nextval[next[j]]"}]},{"ID":"20250206195641-gmknyan","Type":"NodeParagraph","Properties":{"id":"20250206195641-gmknyan","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"否则nextval[j]"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"next[j]."}]},{"ID":"20250206195641-wn6gjfu","Type":"NodeParagraph","Properties":{"id":"20250206195641-wn6gjfu","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/33c7b0b5ac5a2c3505ba276bd51844f3.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-29szokg","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-29szokg","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"void get_nextval(chat t[],int next[],int nextval[])\n{\n    int j=2,k=0;\n    get_next(t,next);\n    nextval[1]=0;\n    while(j\u003c=t.length())\n    {\n        k=next[j];\n        if(t[j]==t[k]) nextval[j]=nextval[j];\n        else nextval[j]=next[j];\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-xmuxllj","Type":"NodeParagraph","Properties":{"id":"20250206195641-xmuxllj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"匹配过程和next的匹配过程类似。"}]},{"ID":"20250206195641-frifava","Type":"NodeParagraph","Properties":{"id":"20250206195641-frifava","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"AC代码"}]},{"ID":"20250206195641-ty4y8ux","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-ty4y8ux","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\nusing namespace std;\n\nconst int N = 100100, M = 1000010;\n\nint n, m;       // n：模式串 p 的长度，m：主串 s 的长度\nint ne[N];      // next 数组（又称为部分匹配表），用于记录模式串 p 中每个位置的最长相等前后缀长度\nchar s[M], p[N]; // s：主串，p：模式串\n                  // 注意：这里均采用 1-indexing，即字符串从下标 1 开始存储\n\n// 求模式串 p 的 next 数组，也就是部分匹配表\nvoid get_next() {\n    // i 从 2 开始，因为位置 1 的 next 值通常为 0（空串没有前后缀匹配）\n    // j 表示当前匹配到的位置（即 p[1...j] 是 p[1...i-1] 的后缀，同时也是前缀）\n    for (int i = 2, j = 0; i \u003c= n; i++) {\n        // 如果 p[i]与 p[j+1]不匹配，就回退 j 到 ne[j]，直到找到合适的 j 或者 j 回退到 0\n        while (j \u0026\u0026 p[i] != p[j + 1])\n            j = ne[j];  // 这里利用已经计算好的部分匹配信息，将 j 回退到较小的匹配值\n      \n        // 如果 p[i]与 p[j+1]匹配，则 j 向前扩展一位\n        if (p[i] == p[j + 1])\n            j++;\n      \n        // 将当前位置 i 的 next 值设为 j，即 p[1...j]为 p[1...i] 的最长相等前后缀\n        ne[i] = j;\n    }\n}\n\n// 利用 KMP 算法在主串 s 中查找模式串 p 出现的位置\nvoid kmp() {\n    // i：遍历主串 s，j：当前匹配模式串 p 的位置\n    for (int i = 1, j = 0; i \u003c= m; i++) {\n        // 当 j \u003e 0 且当前字符 s[i] 与 p[j+1]不匹配时，\n        // 通过 next 数组将 j 回退到较小的匹配状态（即继续尝试匹配）\n        while (j \u0026\u0026 s[i] != p[j + 1])\n            j = ne[j];  // 回退至上一个可能的匹配位置\n      \n        // 如果 s[i] 与 p[j+1]匹配，则 j 向前扩展一位\n        if (s[i] == p[j + 1])\n            j++;\n      \n        // 当 j 达到模式串长度 n 时，说明找到了一个完整匹配\n        if (j == n) {\n            // 输出匹配位置，注意这里输出的是 i - n，\n            // 因为 i 表示匹配结束的位置，i - n 即为匹配起始位置（以 1 为下标时）\n            printf(\"%d \", i - n);\n          \n            // 继续查找下一个匹配，将 j 回退到上一个可能继续匹配的位置\n            j = ne[j];\n        }\n    }\n}\n\nint main() {\n    // 输入格式：首先输入模式串长度 n，\n    // 接着输入模式串 p（从 p+1 开始存储，即 p[1] 为模式串的第一个字符），\n    // 然后输入主串长度 m，接着输入主串 s（同样从 s+1 开始存储）。\n    cin \u003e\u003e n \u003e\u003e (p + 1) \u003e\u003e m \u003e\u003e (s + 1);\n  \n    // 预处理模式串，求出部分匹配表\n    get_next();\n  \n    // 执行 KMP 算法，查找模式串在主串中所有的出现位置\n    kmp();\n  \n    return 0;\n}\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-hsgbjsr","Type":"NodeThematicBreak","Properties":{"id":"20250206195641-hsgbjsr","updated":"20250206195641"}},{"ID":"20250206195641-27of8jp","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-27of8jp","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"并查集"}]},{"ID":"20250206195641-qkwaael","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-qkwaael","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"(1)朴素并查集：\n\n    int p[N]; //存储每个点的祖宗节点\n\n    // 返回x的祖宗节点\n    int find(int x)\n    {\n        if (p[x] != x) p[x] = find(p[x]);\n        return p[x];\n    }\n\n    // 初始化，假定节点编号是1~n\n    for (int i = 1; i \u003c= n; i ++ ) p[i] = i;\n\n    // 合并a和b所在的两个集合：\n    p[find(a)] = find(b);\n\n\n(2)维护size的并查集：\n\n    int p[N], size[N];\n    //p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量\n\n    // 返回x的祖宗节点\n    int find(int x)\n    {\n        if (p[x] != x) p[x] = find(p[x]);\n        return p[x];\n    }\n\n    // 初始化，假定节点编号是1~n\n    for (int i = 1; i \u003c= n; i ++ )\n    {\n        p[i] = i;\n        size[i] = 1;\n    }\n\n    // 合并a和b所在的两个集合：\n    size[find(b)] += size[find(a)];\n    p[find(a)] = find(b);\n\n\n(3)维护到祖宗节点距离的并查集：\n\n    int p[N], d[N];\n    //p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离\n\n    // 返回x的祖宗节点\n    int find(int x)\n    {\n        if (p[x] != x)\n        {\n            int u = find(p[x]);\n            d[x] += d[p[x]];\n            p[x] = u;\n        }\n        return p[x];\n    }\n\n    // 初始化，假定节点编号是1~n\n    for (int i = 1; i \u003c= n; i ++ )\n    {\n        p[i] = i;\n        d[i] = 0;\n    }\n\n    // 合并a和b所在的两个集合：\n    p[find(a)] = find(b);\n    d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-nnncxsu","Type":"NodeThematicBreak","Properties":{"id":"20250206195641-nnncxsu","updated":"20250206195641"}},{"ID":"20250206195641-xfpbe5z","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-xfpbe5z","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"4.1质数"}]},{"ID":"20250206195641-z24978e","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-z24978e","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"4.1.1试除法判定质数"}]},{"ID":"20250206195641-nh5dg5t","Type":"NodeParagraph","Properties":{"id":"20250206195641-nh5dg5t","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"给定 n个正整数 ai，判定每个数是否是质数。"}]},{"ID":"20250206195641-opoenzy","Type":"NodeParagraph","Properties":{"id":"20250206195641-opoenzy","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-9ft1l8o","Type":"NodeParagraph","Properties":{"id":"20250206195641-9ft1l8o","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含整数 n。"}]},{"ID":"20250206195641-1f9ki0e","Type":"NodeParagraph","Properties":{"id":"20250206195641-1f9ki0e","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"接下来 n行，每行包含一个正整数 ai。"}]},{"ID":"20250206195641-f1n9k1c","Type":"NodeParagraph","Properties":{"id":"20250206195641-f1n9k1c","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-e4gp4vh","Type":"NodeParagraph","Properties":{"id":"20250206195641-e4gp4vh","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"共 n行，其中第 i行输出第 i个正整数 ai是否为质数，是则输出 Yes，否则输出 No。"}]},{"ID":"20250206195641-vw42qeo","Type":"NodeParagraph","Properties":{"id":"20250206195641-vw42qeo","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-0ok498h","Type":"NodeParagraph","Properties":{"id":"20250206195641-0ok498h","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤n≤100,"}]},{"ID":"20250206195641-wc06jh7","Type":"NodeParagraph","Properties":{"id":"20250206195641-wc06jh7","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤ai≤2"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"^"}]},{"Type":"NodeText","Data":"31−1"}]},{"ID":"20250206195641-or9v6rt","Type":"NodeParagraph","Properties":{"id":"20250206195641-or9v6rt","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-jcp17d9","Type":"NodeParagraph","Properties":{"id":"20250206195641-jcp17d9","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2"}]},{"ID":"20250206195641-9ffumae","Type":"NodeParagraph","Properties":{"id":"20250206195641-9ffumae","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2"}]},{"ID":"20250206195641-6476ck4","Type":"NodeParagraph","Properties":{"id":"20250206195641-6476ck4","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"6"}]},{"ID":"20250206195641-2bzk360","Type":"NodeParagraph","Properties":{"id":"20250206195641-2bzk360","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-fu3tgzv","Type":"NodeParagraph","Properties":{"id":"20250206195641-fu3tgzv","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"Yes"}]},{"ID":"20250206195641-pjjekya","Type":"NodeParagraph","Properties":{"id":"20250206195641-pjjekya","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"No"}]},{"ID":"20250206195641-kxy3zbw","Type":"NodeParagraph","Properties":{"id":"20250206195641-kxy3zbw","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"用试除法判断一个数n是不是质数的时间复杂度为O(sqrt(n))."}]},{"ID":"20250206195641-7nhur0g","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-7nhur0g","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003cbits/stdc++.h\u003e\n#include\u003calgorithm\u003e\nusing namespace std;\nbool isprime(int n)\n{\n    if(n\u003c2) return false;\n    for(int i=2;i\u003c=n/i;i++)\n    {\n        if(n%i==0) return false;\n    }\n    return true;\n}\nint main()\n{\n    int t;\n    scanf(\"%d\",\u0026t);\n    while(t--)\n    {\n        int n;\n        scanf(\"%d\",\u0026n);\n        if(isprime(n)) printf(\"Yes\\n\");\n        else printf(\"No\\n\");\n    }\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-8rqjbik","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-8rqjbik","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"4.1.2分解质因数"}]},{"ID":"20250206195641-2vb941f","Type":"NodeParagraph","Properties":{"id":"20250206195641-2vb941f","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"给定 n个正整数 ai，将每个数分解质因数，并按照质因数从小到大的顺序输出每个质因数的底数和指数。"}]},{"ID":"20250206195641-ikmjis9","Type":"NodeParagraph","Properties":{"id":"20250206195641-ikmjis9","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-npjczp8","Type":"NodeParagraph","Properties":{"id":"20250206195641-npjczp8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含整数 n。"}]},{"ID":"20250206195641-lbqendz","Type":"NodeParagraph","Properties":{"id":"20250206195641-lbqendz","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"接下来 n行，每行包含一个正整数 ai。"}]},{"ID":"20250206195641-3b9xtwf","Type":"NodeParagraph","Properties":{"id":"20250206195641-3b9xtwf","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-cri6hiw","Type":"NodeParagraph","Properties":{"id":"20250206195641-cri6hiw","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"对于每个正整数 ai，按照从小到大的顺序输出其分解质因数后，每个质因数的底数和指数，每个底数和指数占一行。"}]},{"ID":"20250206195641-5i7rm4g","Type":"NodeParagraph","Properties":{"id":"20250206195641-5i7rm4g","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"每个正整数的质因数全部输出完毕后，输出一个空行。"}]},{"ID":"20250206195641-sebhg6h","Type":"NodeParagraph","Properties":{"id":"20250206195641-sebhg6h","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-nowwsxs","Type":"NodeParagraph","Properties":{"id":"20250206195641-nowwsxs","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤n≤100,"}]},{"ID":"20250206195641-1bv7q1g","Type":"NodeParagraph","Properties":{"id":"20250206195641-1bv7q1g","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2≤ai≤2×1e9"}]},{"ID":"20250206195641-0ppavma","Type":"NodeParagraph","Properties":{"id":"20250206195641-0ppavma","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-s0rw9e1","Type":"NodeParagraph","Properties":{"id":"20250206195641-s0rw9e1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2"}]},{"ID":"20250206195641-n1wgunj","Type":"NodeParagraph","Properties":{"id":"20250206195641-n1wgunj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"6"}]},{"ID":"20250206195641-7p6932z","Type":"NodeParagraph","Properties":{"id":"20250206195641-7p6932z","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"8"}]},{"ID":"20250206195641-ngda2a7","Type":"NodeParagraph","Properties":{"id":"20250206195641-ngda2a7","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-owc0b2n","Type":"NodeParagraph","Properties":{"id":"20250206195641-owc0b2n","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2 1"}]},{"ID":"20250206195641-m6mgyky","Type":"NodeParagraph","Properties":{"id":"20250206195641-m6mgyky","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"3 1"}]},{"ID":"20250206195641-4e1gr95","Type":"NodeParagraph","Properties":{"id":"20250206195641-4e1gr95","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2 3"}]},{"ID":"20250206195641-bddj7ul","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-bddj7ul","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003cbits/stdc++.h\u003e\n#include\u003calgorithm\u003e\nusing namespace std;\nint main()\n{\n    int n;\n    cin\u003e\u003en;\n    while(n--)\n    {\n        int a;\n        cin\u003e\u003ea;\n        for(int i=2;i\u003c=a/i;i++)\n        {\n            if(a%i==0)\n            {\n                int s=0;\n                while(a%i==0)\n                {\n                    a/=i;\n                    s++;\n                }\n                cout\u003c\u003ci\u003c\u003c\" \"\u003c\u003cs\u003c\u003cendl;\n            }\n        }\n        if(a\u003e1) cout\u003c\u003ca\u003c\u003c\" \"\u003c\u003c1\u003c\u003cendl;\n        cout\u003c\u003cendl;\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-l8ebwu7","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-l8ebwu7","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"4.1.3筛质数"}]},{"ID":"20250206195641-jpm3od3","Type":"NodeParagraph","Properties":{"id":"20250206195641-jpm3od3","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"给定一个正整数 n，请你求出 1∼n 中质数的个数。"}]},{"ID":"20250206195641-pz8rdim","Type":"NodeParagraph","Properties":{"id":"20250206195641-pz8rdim","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-8hazqgy","Type":"NodeParagraph","Properties":{"id":"20250206195641-8hazqgy","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"共一行，包含整数 n。"}]},{"ID":"20250206195641-9p7vlz8","Type":"NodeParagraph","Properties":{"id":"20250206195641-9p7vlz8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-zevxhcu","Type":"NodeParagraph","Properties":{"id":"20250206195641-zevxhcu","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"共一行，包含一个整数，表示1∼n 中质数的个数。"}]},{"ID":"20250206195641-bnqa703","Type":"NodeParagraph","Properties":{"id":"20250206195641-bnqa703","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-tapfh6y","Type":"NodeParagraph","Properties":{"id":"20250206195641-tapfh6y","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤n≤1e6"}]},{"ID":"20250206195641-ehhmevl","Type":"NodeParagraph","Properties":{"id":"20250206195641-ehhmevl","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-n5rtp0g","Type":"NodeParagraph","Properties":{"id":"20250206195641-n5rtp0g","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"8"}]},{"ID":"20250206195641-71hnwfy","Type":"NodeParagraph","Properties":{"id":"20250206195641-71hnwfy","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-pamqeku","Type":"NodeParagraph","Properties":{"id":"20250206195641-pamqeku","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"4"}]},{"ID":"20250206195641-stycqzq","Type":"NodeParagraph","Properties":{"id":"20250206195641-stycqzq","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"质数定理：1"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"~"}]},{"Type":"NodeText","Data":"n中有近似n/lnn个质数(粗略计算)"}]},{"ID":"20250206195641-p8yner7","Type":"NodeParagraph","Properties":{"id":"20250206195641-p8yner7","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"当n"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"1e6,线性筛法和埃氏筛法时间近乎一样"}]},{"ID":"20250206195641-fsxicl1","Type":"NodeParagraph","Properties":{"id":"20250206195641-fsxicl1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"当n"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"="}]},{"Type":"NodeText","Data":"1e7,线性筛法比埃氏筛法快一倍"}]},{"ID":"20250206195641-qtqb6a1","Type":"NodeParagraph","Properties":{"id":"20250206195641-qtqb6a1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"st[]数组标记合数"}]},{"ID":"20250206195641-v9hyzw6","Type":"NodeParagraph","Properties":{"id":"20250206195641-v9hyzw6","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(1)朴素筛法O(nlogn)"}]},{"ID":"20250206195641-l45a0ov","Type":"NodeParagraph","Properties":{"id":"20250206195641-l45a0ov","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/a45045472bf705d2b7cc497a97a09f28.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-2x1s2gh","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-2x1s2gh","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\n#include\u003calgorithm\u003e\n#include\u003ccstring\u003e\n#include\u003ccstdio\u003e\nusing namespace std;\nconst int N=1e6+10;\n\nint primes[N],cnt;\nbool st[N];//标记是否被筛过\n\nvoid get_primes(int n)\n{\n    for(int i=2;i\u003c=n;i++)\n    {\n        if(!st[i])\n        {\n            primes[cnt++]=i;\n        }\n        for(int j=i+i;j\u003c=n;j+=i) st[j]=true;//把质数的倍数筛掉，质数的倍数一定是合数\n    }\n}\n\nint main()\n{\n    int n;\n    cin\u003e\u003en;\n\n    get_primes(n);\n\n    cout\u003c\u003ccnt\u003c\u003cendl;\n\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-si38un8","Type":"NodeParagraph","Properties":{"id":"20250206195641-si38un8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(2)埃氏筛法O(nloglogn)近乎O(n)"}]},{"ID":"20250206195641-6c88t05","Type":"NodeParagraph","Properties":{"id":"20250206195641-6c88t05","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/3d52228ce0fc018d250a996d5313550f.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-zcmsfdc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-zcmsfdc","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\n#include\u003calgorithm\u003e\n#include\u003ccstring\u003e\n#include\u003ccstdio\u003e\nusing namespace std;\nconst int N=1e6+10;\n\nint primes[N],cnt;\nbool st[N];//标记是否被筛过\n\nvoid get_primes(int n)\n{\n    for(int i=2;i\u003c=n;i++)\n    {\n        if(!st[i])\n        {\n            primes[cnt++]=i;\n            for(int j=i+i;j\u003c=n;j+=i) st[j]=true;\n        }\n    }\n}\n\nint main()\n{\n    int n;\n    cin\u003e\u003en;\n\n    get_primes(n);\n\n    cout\u003c\u003ccnt\u003c\u003cendl;\n\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-t00bw51","Type":"NodeParagraph","Properties":{"id":"20250206195641-t00bw51","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(3)线性筛法"}]},{"ID":"20250206195641-bsyhivy","Type":"NodeParagraph","Properties":{"id":"20250206195641-bsyhivy","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"线性筛法"}]},{"ID":"20250206195641-wcazzvf","Type":"NodeParagraph","Properties":{"id":"20250206195641-wcazzvf","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"思路：每个合数，只会被它的最小质因子筛掉."}]},{"ID":"20250206195641-09l1eld","Type":"NodeParagraph","Properties":{"id":"20250206195641-09l1eld","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/25b34be17b4ecdd257acd16cbbd53cf5.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-0lzsouw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-0lzsouw","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"void get_primes(){\n    //外层从2~n迭代，因为这毕竟算的是1~n中质数的个数，而不是某个数是不是质数的判定\n    for(int i=2;i\u003c=n;i++){\n        if(!st[i]) primes[cnt++]=i;\n        for(int j=0;primes[j]\u003c=n/i;j++){//primes[j]\u003c=n/i:变形一下得到——primes[j]*i\u003c=n,把大于n的合数都筛了就\n        //没啥意义了\n            st[primes[j]*i]=true;//用最小质因子去筛合数\n\n      /*(1)当i%primes[j]!=0时,说明此时遍历到的primes[j]不是i的质因子，那么只可能是此时的primes[j]\u003ci的          最小质因子,所以primes[j]*i的最小质因子就是primes[j];\n        (2)当有i%primes[j]==0时,说明i的最小质因子是primes[j],因此primes[j]*i的最小质因子也就应该是\n            prime[j]，之后接着用st[primes[j+1]*i]=true去筛合数时，就不是用最小质因子去更新了,因为i有\n            最小质因子primes[j]\u003cprimes[j+1],此时的primes[j+1]不是primes[j+1]*i的最小质因子，此就              应该退出循环，避免之后重复进行筛选。*/\n            if(i%primes[j]==0) break;\n        }\n    }\n\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-y6t23xk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-y6t23xk","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\n#include\u003calgorithm\u003e\n#include\u003ccstring\u003e\n#include\u003ccstdio\u003e\nusing namespace std;\nconst int N=1e6+10;\n\nint primes[N],cnt;\nbool st[N];//标记是否被筛过\n\nvoid get_primes(int n)\n{\n    for(int i=2;i\u003c=n;i++)\n    {\n        if(!st[i]) primes[cnt++]=i;\n        for(int j=0;primes[j]\u003c=n/i;j++)/*从小到大枚举所有的质数，primes[j]*i\u003c=n保证了要筛的合数\n在n的范围内*/\n        {\n            st[primes[j]*i]=true;//每次把当前质数和i的乘积筛掉，也就是筛掉一个合数\n            if(i%primes[j]==0) break;//当这一语句执行，primes[j]一定是i的最小质因子\n        }\n    }\n}\n\nint main()\n{\n    int n;\n    cin\u003e\u003en;\n\n    get_primes(n);\n\n    cout\u003c\u003ccnt\u003c\u003cendl;\n\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-rbcygu6","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-rbcygu6","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"4.2约数"}]},{"ID":"20250206195641-mf4xk65","Type":"NodeParagraph","Properties":{"id":"20250206195641-mf4xk65","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/ffd1753b02172e4d92721ed02cf07771.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-6e2789i","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-6e2789i","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"4.2.1 试除法求约数"}]},{"ID":"20250206195641-ugvc3yw","Type":"NodeParagraph","Properties":{"id":"20250206195641-ugvc3yw","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"给定 n个正整数 ai，对于每个整数 ai，请你按照从小到大的顺序输出它的所有约数。"}]},{"ID":"20250206195641-rxhzgse","Type":"NodeParagraph","Properties":{"id":"20250206195641-rxhzgse","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-sx8rpci","Type":"NodeParagraph","Properties":{"id":"20250206195641-sx8rpci","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含整数 n。"}]},{"ID":"20250206195641-80vzfld","Type":"NodeParagraph","Properties":{"id":"20250206195641-80vzfld","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"接下来 n 行，每行包含一个整数 ai。"}]},{"ID":"20250206195641-xlqfyxb","Type":"NodeParagraph","Properties":{"id":"20250206195641-xlqfyxb","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-980wi6q","Type":"NodeParagraph","Properties":{"id":"20250206195641-980wi6q","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出共 n 行，其中第 i 行输出第 i 个整数 ai 的所有约数。"}]},{"ID":"20250206195641-vr6wkcj","Type":"NodeParagraph","Properties":{"id":"20250206195641-vr6wkcj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-7zno8m0","Type":"NodeParagraph","Properties":{"id":"20250206195641-7zno8m0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤n≤100,"}]},{"ID":"20250206195641-jy8l3yj","Type":"NodeParagraph","Properties":{"id":"20250206195641-jy8l3yj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2≤ai≤2×1e9"}]},{"ID":"20250206195641-jcxfyik","Type":"NodeParagraph","Properties":{"id":"20250206195641-jcxfyik","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-y48suia","Type":"NodeParagraph","Properties":{"id":"20250206195641-y48suia","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2"}]},{"ID":"20250206195641-imp0doh","Type":"NodeParagraph","Properties":{"id":"20250206195641-imp0doh","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"6"}]},{"ID":"20250206195641-g7xtj76","Type":"NodeParagraph","Properties":{"id":"20250206195641-g7xtj76","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"8"}]},{"ID":"20250206195641-tju6cs4","Type":"NodeParagraph","Properties":{"id":"20250206195641-tju6cs4","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-xo6vjuh","Type":"NodeParagraph","Properties":{"id":"20250206195641-xo6vjuh","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1 2 3 6"}]},{"ID":"20250206195641-7dsd2t3","Type":"NodeParagraph","Properties":{"id":"20250206195641-7dsd2t3","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1 2 4 8"}]},{"ID":"20250206195641-tz1yk0u","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-tz1yk0u","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nusing namespace std;\n\nint n;\n\nvoid get_divisors(int n)\n{\n    vector\u003cint\u003e res;\n\n    for (int i = 1; i \u003c= n / i; i++) {\n        if (n % i == 0) {\n            res.push_back(i);\n\n            if (i != n / i) {  // 避免 i==n/i, 重复放入 （n是完全平方数\n                res.push_back(n / i);\n            }\n        }\n    }\n\n    sort(res.begin(), res.end());\n    for (auto item : res) {\n        cout \u003c\u003c item \u003c\u003c \" \";\n    }\n    puts(\"\");\n}\n\nint main()\n{\n    cin \u003e\u003e n;\n    while (n--) {\n        int x;\n        cin \u003e\u003e x;\n        get_divisors(x);\n    }\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-hk5raen","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-hk5raen","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"4.2.2约数个数"}]},{"ID":"20250206195641-j43ygut","Type":"NodeParagraph","Properties":{"id":"20250206195641-j43ygut","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"给定 n 个正整数 ai，请你输出这些数的乘积的约数个数，答案对 1e9+7 取模。"}]},{"ID":"20250206195641-kfzf2j0","Type":"NodeParagraph","Properties":{"id":"20250206195641-kfzf2j0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-sk9qlqv","Type":"NodeParagraph","Properties":{"id":"20250206195641-sk9qlqv","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含整数n。"}]},{"ID":"20250206195641-oynuzwf","Type":"NodeParagraph","Properties":{"id":"20250206195641-oynuzwf","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"接下来 n 行，每行包含一个整数 ai。"}]},{"ID":"20250206195641-ssopf5b","Type":"NodeParagraph","Properties":{"id":"20250206195641-ssopf5b","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-d81ddco","Type":"NodeParagraph","Properties":{"id":"20250206195641-d81ddco","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出一个整数，表示所给正整数的乘积的约数个数，答案需对1e9+7 取模。"}]},{"ID":"20250206195641-52y3d3l","Type":"NodeParagraph","Properties":{"id":"20250206195641-52y3d3l","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-vfk97be","Type":"NodeParagraph","Properties":{"id":"20250206195641-vfk97be","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤n≤100,"}]},{"ID":"20250206195641-9uqg0af","Type":"NodeParagraph","Properties":{"id":"20250206195641-9uqg0af","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤ai≤2×1e9"}]},{"ID":"20250206195641-73z5uwb","Type":"NodeParagraph","Properties":{"id":"20250206195641-73z5uwb","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-1jlstga","Type":"NodeParagraph","Properties":{"id":"20250206195641-1jlstga","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"3"}]},{"ID":"20250206195641-kdysz9m","Type":"NodeParagraph","Properties":{"id":"20250206195641-kdysz9m","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2"}]},{"ID":"20250206195641-rc326y2","Type":"NodeParagraph","Properties":{"id":"20250206195641-rc326y2","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"6"}]},{"ID":"20250206195641-02sto1j","Type":"NodeParagraph","Properties":{"id":"20250206195641-02sto1j","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"8"}]},{"ID":"20250206195641-pvx4ka4","Type":"NodeParagraph","Properties":{"id":"20250206195641-pvx4ka4","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-adc6uc1","Type":"NodeParagraph","Properties":{"id":"20250206195641-adc6uc1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"12"}]},{"ID":"20250206195641-pu5tr8a","Type":"NodeParagraph","Properties":{"id":"20250206195641-pu5tr8a","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/6d0c4dc2f9ca0f319d0c0359cf4c4a95.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-6qq89wh","Type":"NodeParagraph","Properties":{"id":"20250206195641-6qq89wh","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/bf2d9eb56fcefcfcfae1eeda8f257097.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-n1t7rn7","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-n1t7rn7","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003cbits/stdc++.h\u003e\nusing namespace std;\ntypedef long long LL;\nconst int mod=1e9+7;\nint main()\n{\n    int n,x;\n    LL ans=1;\n    unordered_map\u003cint,int\u003e hash;\n    cin\u003e\u003en;\n    while(n--)\n    {\n        cin\u003e\u003ex;\n        for(int i=2;i\u003c=x/i;i++)\n        {\n            while(x%i==0)\n            {\n                x/=i;\n                hash[i]++;\n            }\n        }\n        if(x\u003e1) hash[x]++;\n    }\n    for(auto i:hash) ans=ans*(i.second+1)%mod;\n    cout\u003c\u003cans;\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-nfy5qeg","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-nfy5qeg","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"4.2.3约数之和"}]},{"ID":"20250206195641-j4q6ond","Type":"NodeParagraph","Properties":{"id":"20250206195641-j4q6ond","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"给定 n 个正整数 ai，请你输出这些数的乘积的约数之和，答案对 1e9+7 取模。"}]},{"ID":"20250206195641-jj0s1pd","Type":"NodeParagraph","Properties":{"id":"20250206195641-jj0s1pd","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-oiail1f","Type":"NodeParagraph","Properties":{"id":"20250206195641-oiail1f","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含整数 n。"}]},{"ID":"20250206195641-r17ebeg","Type":"NodeParagraph","Properties":{"id":"20250206195641-r17ebeg","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"接下来 n 行，每行包含一个整数 ai。"}]},{"ID":"20250206195641-wwinig2","Type":"NodeParagraph","Properties":{"id":"20250206195641-wwinig2","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-ui395wv","Type":"NodeParagraph","Properties":{"id":"20250206195641-ui395wv","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出一个整数，表示所给正整数的乘积的约数之和，答案需对 1e9+7 取模。"}]},{"ID":"20250206195641-bv6t6jk","Type":"NodeParagraph","Properties":{"id":"20250206195641-bv6t6jk","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-hupk231","Type":"NodeParagraph","Properties":{"id":"20250206195641-hupk231","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤n≤100,"}]},{"ID":"20250206195641-9cjvesv","Type":"NodeParagraph","Properties":{"id":"20250206195641-9cjvesv","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤ai≤2×1e9"}]},{"ID":"20250206195641-zetejgq","Type":"NodeParagraph","Properties":{"id":"20250206195641-zetejgq","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-0zdj5cr","Type":"NodeParagraph","Properties":{"id":"20250206195641-0zdj5cr","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"3"}]},{"ID":"20250206195641-0r96kf5","Type":"NodeParagraph","Properties":{"id":"20250206195641-0r96kf5","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2"}]},{"ID":"20250206195641-v1j8ih3","Type":"NodeParagraph","Properties":{"id":"20250206195641-v1j8ih3","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"6"}]},{"ID":"20250206195641-j75uwms","Type":"NodeParagraph","Properties":{"id":"20250206195641-j75uwms","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"8"}]},{"ID":"20250206195641-c9ce6k1","Type":"NodeParagraph","Properties":{"id":"20250206195641-c9ce6k1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-aavlopl","Type":"NodeParagraph","Properties":{"id":"20250206195641-aavlopl","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"252"}]},{"ID":"20250206195641-yk9teun","Type":"NodeParagraph","Properties":{"id":"20250206195641-yk9teun","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/8820126454e9090587d6c1fea281c9a1.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-d8zyvcs","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-d8zyvcs","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003calgorithm\u003e\n#include \u003cunordered_map\u003e\n#include \u003cvector\u003e\n\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N = 110, mod = 1e9 + 7;\n\nint main()\n{\n    int n;\n    cin \u003e\u003e n;\n\n    unordered_map\u003cint, int\u003e primes;\n\n    while (n -- )\n    {\n        int x;\n        cin \u003e\u003e x;\n\n        for (int i = 2; i \u003c= x / i; i ++ )\n            while (x % i == 0)\n            {\n                x /= i;\n                primes[i] ++ ;\n            }\n\n        if (x \u003e 1) primes[x] ++ ;\n    }\n\n    LL res = 1;\n    for (auto p : primes)\n    {\n        LL a = p.first, b = p.second;\n        LL t = 1;\n        while (b -- ) t = (t * a + 1) % mod;\n        res = res * t % mod;\n    }\n\n    cout \u003c\u003c res \u003c\u003c endl;\n\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-1m8s73j","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-1m8s73j","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"4.2.4最大公约数"}]},{"ID":"20250206195641-vei19aj","Type":"NodeParagraph","Properties":{"id":"20250206195641-vei19aj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"给定 n 对正整数ai,bi，请你求出每对数的最大公约数。"}]},{"ID":"20250206195641-ydj4fxn","Type":"NodeParagraph","Properties":{"id":"20250206195641-ydj4fxn","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-8qpx9pr","Type":"NodeParagraph","Properties":{"id":"20250206195641-8qpx9pr","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含整数 n。"}]},{"ID":"20250206195641-1jy0xmj","Type":"NodeParagraph","Properties":{"id":"20250206195641-1jy0xmj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"接下来 n 行，每行包含一个整数对 ai,bi。"}]},{"ID":"20250206195641-efvszm4","Type":"NodeParagraph","Properties":{"id":"20250206195641-efvszm4","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-9pzjnv4","Type":"NodeParagraph","Properties":{"id":"20250206195641-9pzjnv4","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出共 n 行，每行输出一个整数对的最大公约数。"}]},{"ID":"20250206195641-kn6f2n8","Type":"NodeParagraph","Properties":{"id":"20250206195641-kn6f2n8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-is5az4q","Type":"NodeParagraph","Properties":{"id":"20250206195641-is5az4q","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤n≤1e5,"}]},{"ID":"20250206195641-6elm786","Type":"NodeParagraph","Properties":{"id":"20250206195641-6elm786","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤ai,bi≤2×1e9"}]},{"ID":"20250206195641-fg2birb","Type":"NodeParagraph","Properties":{"id":"20250206195641-fg2birb","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-d0q2ue9","Type":"NodeParagraph","Properties":{"id":"20250206195641-d0q2ue9","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2"}]},{"ID":"20250206195641-9vvxwol","Type":"NodeParagraph","Properties":{"id":"20250206195641-9vvxwol","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"3 6"}]},{"ID":"20250206195641-wqojkj1","Type":"NodeParagraph","Properties":{"id":"20250206195641-wqojkj1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"4 6"}]},{"ID":"20250206195641-oru4vyj","Type":"NodeParagraph","Properties":{"id":"20250206195641-oru4vyj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-mdtlsb4","Type":"NodeParagraph","Properties":{"id":"20250206195641-mdtlsb4","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"3"}]},{"ID":"20250206195641-ii2973c","Type":"NodeParagraph","Properties":{"id":"20250206195641-ii2973c","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2"}]},{"ID":"20250206195641-0vvothy","Type":"NodeParagraph","Properties":{"id":"20250206195641-0vvothy","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/a7b59c7101b98feb199d1bbb29d7f1a9.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-dpjvxup","Type":"NodeParagraph","Properties":{"id":"20250206195641-dpjvxup","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/3680976b9de16cb3b0bd9b2e83a42217.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-hztkpz9","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-hztkpz9","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003cbits/stdc++.h\u003e\nusing namespace std;\nint gcd(int a,int b)\n{\n    return b ? gcd(b,a%b) : a;\n}\nint main()\n{\n    int n;\n    scanf(\"%d\",\u0026n);\n    while(n--)\n    {\n        int a,b;\n        scanf(\"%d%d\",\u0026a,\u0026b);\n        printf(\"%d\\n\",gcd(a,b));\n    }\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-1dxvljy","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-1dxvljy","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"int gcd(int a,int b){\n    if(b \u003e 0) return gcd(b,a % b); //如果b大于0，那么继续除\n    else return a; //否则直接返回a\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-c2w96n4","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-c2w96n4","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"进制转换模板"}]},{"ID":"20250206195641-al3otrv","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-al3otrv","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"\n#include \u003ciostream\u003e\nusing namespace std;\n\nvoid toTridecimal(int a) {\n    if (a \u003e= 13) toTridecimal(a / 13);\n    int remainder = a % 13;\n    if (remainder \u003c 10) cout \u003c\u003c remainder;\n    else cout \u003c\u003c char('a' + remainder - 10);\n}\n\nint main() {\n    int a;\n    cin \u003e\u003e a;\n    if (a == 0) cout \u003c\u003c 0; // 特殊情况处理，当输入为0时直接输出0\n    else toTridecimal(a);\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-c5zkani","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-c5zkani","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"堆"}]},{"ID":"20250206195641-86xfw5v","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-86xfw5v","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1\n// ph[k]存储第k个插入的点在堆中的位置\n// hp[k]存储堆中下标是k的点是第几个插入的\nint h[N], ph[N], hp[N], size;\n\n// 交换两个点，及其映射关系\nvoid heap_swap(int a, int b)\n{\n    swap(ph[hp[a]],ph[hp[b]]);\n    swap(hp[a], hp[b]);\n    swap(h[a], h[b]);\n}\n\nvoid down(int u)\n{\n    int t = u;\n    if (u * 2 \u003c= size \u0026\u0026 h[u * 2] \u003c h[t]) t = u * 2;\n    if (u * 2 + 1 \u003c= size \u0026\u0026 h[u * 2 + 1] \u003c h[t]) t = u * 2 + 1;\n    if (u != t)\n    {\n        heap_swap(u, t);\n        down(t);\n    }\n}\n\nvoid up(int u)\n{\n    while (u / 2 \u0026\u0026 h[u] \u003c h[u / 2])\n    {\n        heap_swap(u, u / 2);\n        u \u003e\u003e= 1;\n    }\n}\n\n// O(n)建堆\nfor (int i = n / 2; i; i -- ) down(i);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-743f1nd","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-743f1nd","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"堆排序"}]},{"ID":"20250206195641-00ya80s","Type":"NodeParagraph","Properties":{"id":"20250206195641-00ya80s","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入一个长度为 n的整数数列，从小到大输出前 m小的数。"}]},{"ID":"20250206195641-a4zwggm","Type":"NodeParagraph","Properties":{"id":"20250206195641-a4zwggm","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-0jvlew7","Type":"NodeParagraph","Properties":{"id":"20250206195641-0jvlew7","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含整数 n和 m。"}]},{"ID":"20250206195641-30urq50","Type":"NodeParagraph","Properties":{"id":"20250206195641-30urq50","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第二行包含 n个整数，表示整数数列。"}]},{"ID":"20250206195641-8c7esgw","Type":"NodeParagraph","Properties":{"id":"20250206195641-8c7esgw","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-216n7uv","Type":"NodeParagraph","Properties":{"id":"20250206195641-216n7uv","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"共一行，包含 m个整数，表示整数数列中前 m小的数。"}]},{"ID":"20250206195641-8gv4oyt","Type":"NodeParagraph","Properties":{"id":"20250206195641-8gv4oyt","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-9jea7f9","Type":"NodeParagraph","Properties":{"id":"20250206195641-9jea7f9","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤m≤n≤1e5，"}]},{"ID":"20250206195641-kdr609j","Type":"NodeParagraph","Properties":{"id":"20250206195641-kdr609j","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤数列中元素≤1e9"}]},{"ID":"20250206195641-tv027kf","Type":"NodeParagraph","Properties":{"id":"20250206195641-tv027kf","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-gwjhkqj","Type":"NodeParagraph","Properties":{"id":"20250206195641-gwjhkqj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"5 3"}]},{"ID":"20250206195641-vm0vn8s","Type":"NodeParagraph","Properties":{"id":"20250206195641-vm0vn8s","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"4 5 1 3 2"}]},{"ID":"20250206195641-6nxa22w","Type":"NodeParagraph","Properties":{"id":"20250206195641-6nxa22w","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-0dhgwdm","Type":"NodeParagraph","Properties":{"id":"20250206195641-0dhgwdm","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1 2 3"}]},{"ID":"20250206195641-yjmq0ee","Type":"NodeParagraph","Properties":{"id":"20250206195641-yjmq0ee","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"一、堆的基本概念"}]},{"ID":"20250206195641-dvjdv6f","Type":"NodeParagraph","Properties":{"id":"20250206195641-dvjdv6f","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"堆：是一个完全二叉树。"}]},{"ID":"20250206195641-ow8swco","Type":"NodeParagraph","Properties":{"id":"20250206195641-ow8swco","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"堆分成两类，小根堆和大根堆。"}]},{"ID":"20250206195641-p3oyal8","Type":"NodeParagraph","Properties":{"id":"20250206195641-p3oyal8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"小根堆：父节点小于等于左右孩子节点；"}]},{"ID":"20250206195641-ebequqy","Type":"NodeParagraph","Properties":{"id":"20250206195641-ebequqy","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"大根堆：父节点大于等于左右孩子节点。"}]},{"ID":"20250206195641-6ao4vt8","Type":"NodeParagraph","Properties":{"id":"20250206195641-6ao4vt8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"STL里面的堆又称为优先队列；"}]},{"ID":"20250206195641-37eewny","Type":"NodeParagraph","Properties":{"id":"20250206195641-37eewny","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"如何手写一个堆？"}]},{"ID":"20250206195641-awg1js1","Type":"NodeParagraph","Properties":{"id":"20250206195641-awg1js1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"本篇文章以小根堆为例，实现堆的一些基本的操作。"}]},{"ID":"20250206195641-1clr1hh","Type":"NodeParagraph","Properties":{"id":"20250206195641-1clr1hh","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"我们用一维数组来维护一个堆，规定数组的下标从1开始，每个下标的左右儿子分别为2"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"*"}]},{"Type":"NodeText","Data":"x，2"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"*"}]},{"Type":"NodeText","Data":"x+1；"}]},{"ID":"20250206195641-p58c2ig","Type":"NodeParagraph","Properties":{"id":"20250206195641-p58c2ig","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/c03be99dee2ca2b0b3bdd2a354d6f14a.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-35yskw0","Type":"NodeParagraph","Properties":{"id":"20250206195641-35yskw0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"我们先讲述堆中两个最基本的操作down(x),up(x)两个操作。"}]},{"ID":"20250206195641-oc6ty3p","Type":"NodeParagraph","Properties":{"id":"20250206195641-oc6ty3p","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"down(x),如果我们修改堆某个节点或者删除某个节点 ，我们就需要用down和up来维护我们堆中的关系，我们以小根堆为例，如果父节点变大，那么他就要往下沉，因为我们小根堆满足父节点小于等于左右儿子，同理，up恰好相反，如果父节点变小，它就要和自己的父节点比较，直到满足小根堆的定义为止。"}]},{"ID":"20250206195641-9qt6p2k","Type":"NodeParagraph","Properties":{"id":"20250206195641-9qt6p2k","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"二、堆的基本操作"}]},{"ID":"20250206195641-26ffx1i","Type":"NodeParagraph","Properties":{"id":"20250206195641-26ffx1i","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"那么我们就可以用down和up操作完成堆中最基本的操作："}]},{"ID":"20250206195641-egxnm7c","Type":"NodeParagraph","Properties":{"id":"20250206195641-egxnm7c","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1.插入一个数"}]},{"ID":"20250206195641-mrm3y4h","Type":"NodeParagraph","Properties":{"id":"20250206195641-mrm3y4h","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"我们插入一个数一般是插入到堆中最后一个数的后面再进行up操作。"}]},{"ID":"20250206195641-rv95xgy","Type":"NodeParagraph","Properties":{"id":"20250206195641-rv95xgy","updated":"20250206195641"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"heap[++size]=x,up(size);"}]},{"ID":"20250206195641-9vav27j","Type":"NodeParagraph","Properties":{"id":"20250206195641-9vav27j","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2.求集合当中的最小值"}]},{"ID":"20250206195641-nvtn7qj","Type":"NodeParagraph","Properties":{"id":"20250206195641-nvtn7qj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"因为是小根堆，我们堆顶元素是最小值。"}]},{"ID":"20250206195641-tcgh2ai","Type":"NodeParagraph","Properties":{"id":"20250206195641-tcgh2ai","updated":"20250206195641"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"heap[1];"}]},{"ID":"20250206195641-1l18jlm","Type":"NodeParagraph","Properties":{"id":"20250206195641-1l18jlm","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"3.删除最小值"}]},{"ID":"20250206195641-kugs2x4","Type":"NodeParagraph","Properties":{"id":"20250206195641-kugs2x4","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"我们需要删除堆顶元素，都是如果直接删除堆顶元素的话，会很麻烦，我们可以用最后一个元素来覆盖堆顶元素，如何进行down(1)操作。"}]},{"ID":"20250206195641-apdb0j4","Type":"NodeParagraph","Properties":{"id":"20250206195641-apdb0j4","updated":"20250206195641"},"Children":[{"Type":"NodeTextMark","TextMarkType":"strong","TextMarkTextContent":"heap[1]=heap[size];size--;down(1);"}]},{"ID":"20250206195641-w1og75f","Type":"NodeParagraph","Properties":{"id":"20250206195641-w1og75f","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"4.删除任意一个值"}]},{"ID":"20250206195641-a14h8iy","Type":"NodeParagraph","Properties":{"id":"20250206195641-a14h8iy","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"我们类似于删除堆顶元素的操作，我们先用最后一个元素的值覆盖删除元素的值，因为我们不知道覆盖后的元素是变大还是变小了，所有我们需要判断是执行up还是down。"}]},{"ID":"20250206195641-w0fp8xo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-w0fp8xo","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"int t\\=heap[k];\n\nheap[k]\\=heap[size];\n\nsize--;\n\nif(heap[k]\\\u003et) down(k);\n\nelse up(k);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-rjey4ud","Type":"NodeParagraph","Properties":{"id":"20250206195641-rjey4ud","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"当然我们可以简化："}]},{"ID":"20250206195641-0wsespc","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-0wsespc","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"heap[k]\\=heap[size];\n\nsize--;\n\ndown(k);\n\nup(k);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-7bqbcvu","Type":"NodeParagraph","Properties":{"id":"20250206195641-7bqbcvu","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"5.修改任意一个元素"}]},{"ID":"20250206195641-o828wq6","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-o828wq6","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"heap[k]\\=x;\n\ndown(k);\n\nup(k);\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-t0djb84","Type":"NodeParagraph","Properties":{"id":"20250206195641-t0djb84","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeLinkText","Data":"屏幕截图 2025-02-05 180008"},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"assets/屏幕截图 2025-02-05 180008-20250205180100-bznqdk2.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"AC代码"}]},{"ID":"20250206195641-o57wufk","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-o57wufk","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\n#include\u003calgorithm\u003e\n#include\u003ccstring\u003e\nusing namespace std;\nconst int N=1e5+10;\nint h[N],siz;\nint n,m;\n\nvoid down(int u)\n{\n    int t=u;//t存储3个节点中的最小值，开始时假设最小值为父节点\n    if(2*u\u003c=siz\u0026\u0026h[2*u]\u003ch[t]) t=2*u;//和左儿子比较\n    if(2*u+1\u003c=siz\u0026\u0026h[2*u+1]\u003ch[t]) t=2*u+1;//和右儿子比较\n    if(t!=u)\n    {\n        swap(h[t],h[u]);\n        down(t);\n    }\n}\n\nint main()\n{\n    cin\u003e\u003en\u003e\u003em;\n    for(int i=1;i\u003c=n;i++) cin\u003e\u003eh[i];\n    siz=n;\n    for(int i=n/2;i;i--) down(i);\n    while(m--)\n    {\n        cout\u003c\u003ch[1]\u003c\u003c\" \";\n        h[1]=h[siz];\n        siz--;\n        down(1);\n    }\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-73ffeiw","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-73ffeiw","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"拓扑排序"}]},{"ID":"20250206195641-t6fss9s","Type":"NodeParagraph","Properties":{"id":"20250206195641-t6fss9s","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"给定一个 n个点 m 条边的有向图，点的编号是 1 到 n，图中可能存在重边和自环。"}]},{"ID":"20250206195641-maw5t1h","Type":"NodeParagraph","Properties":{"id":"20250206195641-maw5t1h","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"请输出任意一个该有向图的拓扑序列，如果拓扑序列不存在，则输出 −1。"}]},{"ID":"20250206195641-svg7vyk","Type":"NodeParagraph","Properties":{"id":"20250206195641-svg7vyk","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"若一个由图中所有点构成的序列 A 满足：对于图中的每条边 (x,y)，x 在 A 中都出现在 y之前，则称 A是该图的一个拓扑序列。"}]},{"ID":"20250206195641-qwt5vnv","Type":"NodeParagraph","Properties":{"id":"20250206195641-qwt5vnv","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-goi9or1","Type":"NodeParagraph","Properties":{"id":"20250206195641-goi9or1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含两个整数 n和 m。"}]},{"ID":"20250206195641-jir3tkr","Type":"NodeParagraph","Properties":{"id":"20250206195641-jir3tkr","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"接下来 m 行，每行包含两个整数 x 和 y，表示存在一条从点 x 到点 y 的有向边 (x,y)。"}]},{"ID":"20250206195641-19isy4v","Type":"NodeParagraph","Properties":{"id":"20250206195641-19isy4v","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-s8ujrr6","Type":"NodeParagraph","Properties":{"id":"20250206195641-s8ujrr6","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"共一行，如果存在拓扑序列，则输出任意一个合法的拓扑序列即可。"}]},{"ID":"20250206195641-dux0qlm","Type":"NodeParagraph","Properties":{"id":"20250206195641-dux0qlm","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"否则输出 −1。"}]},{"ID":"20250206195641-03aqtno","Type":"NodeParagraph","Properties":{"id":"20250206195641-03aqtno","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-hga117e","Type":"NodeParagraph","Properties":{"id":"20250206195641-hga117e","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤n,m≤1e5"}]},{"ID":"20250206195641-rliznxy","Type":"NodeParagraph","Properties":{"id":"20250206195641-rliznxy","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-j6izpqx","Type":"NodeParagraph","Properties":{"id":"20250206195641-j6izpqx","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"3 3"}]},{"ID":"20250206195641-fkikikd","Type":"NodeParagraph","Properties":{"id":"20250206195641-fkikikd","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1 2"}]},{"ID":"20250206195641-0uz0ail","Type":"NodeParagraph","Properties":{"id":"20250206195641-0uz0ail","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2 3"}]},{"ID":"20250206195641-xwnsbnz","Type":"NodeParagraph","Properties":{"id":"20250206195641-xwnsbnz","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1 3"}]},{"ID":"20250206195641-s04gebh","Type":"NodeParagraph","Properties":{"id":"20250206195641-s04gebh","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-3g5pgvy","Type":"NodeParagraph","Properties":{"id":"20250206195641-3g5pgvy","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1 2 3"}]},{"ID":"20250206195641-ehhyfm5","Type":"NodeParagraph","Properties":{"id":"20250206195641-ehhyfm5","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"思路："}]},{"ID":"20250206195641-455870x","Type":"NodeParagraph","Properties":{"id":"20250206195641-455870x","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/2cd82d620e8930292975a7f4c765f588.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-j6rphi6","Type":"NodeParagraph","Properties":{"id":"20250206195641-j6rphi6","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"AC代码"}]},{"ID":"20250206195641-ywewxdf","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-ywewxdf","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\n#include\u003calgorithm\u003e\n#include\u003ccstring\u003e\n#include\u003ccstdio\u003e\nusing namespace std;\nconst int N=1e6+10;\n\n//邻接表表示方法\nint h[N],e[N*2],ne[N*2],idx;\n\nint d[N*2];\nint q[N*2];//定义一个队列\nint n,m;\n\nvoid add(int a,int b)\n{\n    e[idx]=b,ne[idx]=h[a],h[a]=idx++;\n}\n\nbool topsort()\n{\n    int hh=0,tt=-1;\n    for(int i=1;i\u003c=n;i++)\n        if(!d[i]) q[++tt]=i;//将入度为0的点入队\n    while(hh\u003c=tt)\n    {\n        auto t=q[hh++];\n        for(int i=h[t];i!=-1;i=ne[i])\n        {\n            int j=e[i];\n            d[j]--;\n            if(d[j]==0) q[++tt]=j;\n        }\n    }\n    return tt==n-1;//如果队列里面有n个点，则存在拓扑序列，否则有环，不存在拓扑序列\n}\n\nint main()\n{\n    memset(h,-1,sizeof h);\n    cin\u003e\u003en\u003e\u003em;\n    for(int i=1;i\u003c=m;i++)\n    {\n        int a,b;\n        cin\u003e\u003ea\u003e\u003eb;\n        add(a,b);\n        d[b]++;//b的入度++\n    }\n    if(topsort())\n    {\n        for(int i=0;i\u003cn;i++)\n            cout\u003c\u003cq[i]\u003c\u003c\" \";\n        puts(\"\");\n    }\n    else puts(\"-1\");\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-mcz0ucj","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-mcz0ucj","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"拓扑排序stl实现"}]},{"ID":"20250206195641-l8naftq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-l8naftq","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\n#include\u003calgorithm\u003e\n#include\u003ccstring\u003e\n#include\u003ccstdio\u003e\n#include\u003cqueue\u003e\nusing namespace std;\nconst int N=1e6+10;\n\n// 邻接表存储图\nint h[N], e[N*2], ne[N*2], idx; // h: 头节点，e: 目标点，ne: 下一条边，idx: 记录边序号\nint d[N*2]; // 记录入度\nqueue\u003cint\u003e q;\nint n, m; // 节点数，边数\n\n// 添加边 a -\u003e b\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++; // 建立邻接表\n}\n\n// 拓扑排序（Kahn 算法）\nbool topsort()\n{\n    for(int i = 1; i \u003c= n; i++)\n        if(!d[i]) q.push(i); // 先将入度为 0 的点入队\n\n    int cnt = 0; // 统计拓扑序列中的节点数\n    while(!q.empty())\n    {\n        int t = q.front(); q.pop(); // 取出队头\n        for(int i = h[t]; i != -1; i = ne[i]) // 遍历 t 的所有出边\n        {\n            int j = e[i]; // 目标节点\n            d[j]--; // 入度减少\n            if(d[j] == 0) q.push(j); // 入度变 0，入队\n        }\n        cnt++; // 统计遍历的点数\n    }\n    return cnt == n; // 如果遍历所有点，说明无环，否则有环\n}\n\nint main()\n{\n    memset(h, -1, sizeof h); // 初始化邻接表（所有点无边）\n  \n    cin \u003e\u003e n \u003e\u003e m;\n    for(int i = 1; i \u003c= m; i++)\n    {\n        int a, b;\n        cin \u003e\u003e a \u003e\u003e b;\n        add(a, b); // 添加有向边 a -\u003e b\n        d[b]++; // b 的入度 +1\n    }\n\n    if(topsort()) puts(\"1\"); // 无环\n    else puts(\"-1\"); // 有环\n    return 0;\n}\n\n\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-fcil8up","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-fcil8up","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"树和图的一些预备知识"}]},{"ID":"20250206195641-9502294","Type":"NodeParagraph","Properties":{"id":"20250206195641-9502294","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"树与图的存储"}]},{"ID":"20250206195641-2pn3a8j","Type":"NodeParagraph","Properties":{"id":"20250206195641-2pn3a8j","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"树是一种特殊的图，与图的存储方式相同。"}]},{"ID":"20250206195641-e4r1ucl","Type":"NodeParagraph","Properties":{"id":"20250206195641-e4r1ucl","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"对于无向图中的边ab，存储两条有向边a-"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"\u003e"}]},{"Type":"NodeText","Data":"b, b-"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"\u003e"}]},{"Type":"NodeText","Data":"a。"}]},{"ID":"20250206195641-azzg9w7","Type":"NodeParagraph","Properties":{"id":"20250206195641-azzg9w7","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"因此我们可以只考虑有向图的存储。"}]},{"ID":"20250206195641-wsmy1to","Type":"NodeParagraph","Properties":{"id":"20250206195641-wsmy1to","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"n：点数，m：边数"}]},{"ID":"20250206195641-i12raoj","Type":"NodeParagraph","Properties":{"id":"20250206195641-i12raoj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"稀疏图:如果m和n是一个级别的，用邻接表。"}]},{"ID":"20250206195641-xfywcg3","Type":"NodeParagraph","Properties":{"id":"20250206195641-xfywcg3","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"稠密图:如果m和n"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"^"}]},{"Type":"NodeText","Data":"2是一个级别的，用邻接矩阵。"}]},{"ID":"20250206195641-142ykhj","Type":"NodeParagraph","Properties":{"id":"20250206195641-142ykhj","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(1) 邻接矩阵：g[a][b] 存储边a-"},{"Type":"NodeBackslash","Children":[{"Type":"NodeBackslashContent","Data":"\u003e"}]},{"Type":"NodeText","Data":"b，先初始化g位正无穷"}]},{"ID":"20250206195641-07ok8gw","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-07ok8gw","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"memset(g,0x3f,sizeof g);\ng[a][b]=c;\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-vxilhx3","Type":"NodeParagraph","Properties":{"id":"20250206195641-vxilhx3","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(2) 邻接表："}]},{"ID":"20250206195641-qnzl66x","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-qnzl66x","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"// 对于每个点k，开一个单链表，存储k所有可以走到的点。h[k]存储这个单链表的头结点\nint h[N], e[N], ne[N], idx;\n\n// 添加一条边a-\u003eb\nvoid add(int a, int b)\n{\n    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;\n}\n\n// 初始化\nidx = 0;\nmemset(h, -1, sizeof h);//初始化表头\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-2ewgwqg","Type":"NodeParagraph","Properties":{"id":"20250206195641-2ewgwqg","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(1) 深度优先遍历"}]},{"ID":"20250206195641-ef7qiug","Type":"NodeParagraph","Properties":{"id":"20250206195641-ef7qiug","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"时间复杂度 O(n+m) ，n表示点数，m表示边数."}]},{"ID":"20250206195641-a8ia0vr","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-a8ia0vr","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"int dfs(int u)\n{\n    st[u] = true; // st[u] 表示点u已经被遍历过\n\n    for (int i = h[u]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (!st[j]) dfs(j);\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-3c7mb0j","Type":"NodeParagraph","Properties":{"id":"20250206195641-3c7mb0j","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"(2) 宽度优先遍历"}]},{"ID":"20250206195641-bbawrib","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-bbawrib","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"queue\u003cint\u003e q;\nst[1] = true; // 表示1号点已经被遍历过\nq.push(1);\n\nwhile (q.size())\n{\n    int t = q.front();\n    q.pop();\n\n    for (int i = h[t]; i != -1; i = ne[i])\n    {\n        int j = e[i];\n        if (!st[j])\n        {\n            st[j] = true; // 表示点j已经被遍历过\n            q.push(j);\n        }\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-yi2u8oa","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-yi2u8oa","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"3.3树的深度优先遍历"}]},{"ID":"20250206195641-soersg2","Type":"NodeParagraph","Properties":{"id":"20250206195641-soersg2","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"树和图的深度优先遍历的模板："}]},{"ID":"20250206195641-gme4e6j","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-gme4e6j","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"// 需要标记数组st[N],  遍历节点的每个相邻的便\nvoid dfs(int u) {\n    st[u] = true; // 标记一下，记录为已经被搜索过了，下面进行搜索过程\n    for (int i = h[u]; i != -1; i = ne[i]) {\n        int j = e[i];\n        if (!st[j]) {\n            dfs(j);\n        }\n    }\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-xm99fsz","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-xm99fsz","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"3.3.1树的重心"}]},{"ID":"20250206195641-d2gcjii","Type":"NodeParagraph","Properties":{"id":"20250206195641-d2gcjii","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"给定一颗树，树中包含 n个结点（编号 1∼n）和 n−1 条无向边。"}]},{"ID":"20250206195641-eio7q6f","Type":"NodeParagraph","Properties":{"id":"20250206195641-eio7q6f","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"请你找到树的重心，并输出将重心删除后，剩余各个连通块中点数的最大值。"}]},{"ID":"20250206195641-hvv6qw5","Type":"NodeParagraph","Properties":{"id":"20250206195641-hvv6qw5","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"重心定义：重心是指树中的一个结点，如果将这个点删除后，剩余各个连通块中点数的最大值最小，那么这个节点被称为树的重心。"}]},{"ID":"20250206195641-yfgp269","Type":"NodeParagraph","Properties":{"id":"20250206195641-yfgp269","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-8porndh","Type":"NodeParagraph","Properties":{"id":"20250206195641-8porndh","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含整数 n，表示树的结点数。"}]},{"ID":"20250206195641-19tfcjb","Type":"NodeParagraph","Properties":{"id":"20250206195641-19tfcjb","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"接下来 n−1行，每行包含两个整数 a和 b，表示点 a和点 b之间存在一条边。"}]},{"ID":"20250206195641-98cd82q","Type":"NodeParagraph","Properties":{"id":"20250206195641-98cd82q","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-j1ac5ah","Type":"NodeParagraph","Properties":{"id":"20250206195641-j1ac5ah","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出一个整数 m，表示将重心删除后，剩余各个连通块中点数的最大值。"}]},{"ID":"20250206195641-n12k36b","Type":"NodeParagraph","Properties":{"id":"20250206195641-n12k36b","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-acuxvql","Type":"NodeParagraph","Properties":{"id":"20250206195641-acuxvql","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤n≤1e5"}]},{"ID":"20250206195641-245sjq3","Type":"NodeParagraph","Properties":{"id":"20250206195641-245sjq3","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例"}]},{"ID":"20250206195641-iyssuq8","Type":"NodeParagraph","Properties":{"id":"20250206195641-iyssuq8","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"9"}]},{"ID":"20250206195641-sliae77","Type":"NodeParagraph","Properties":{"id":"20250206195641-sliae77","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1 2"}]},{"ID":"20250206195641-p2ppcdd","Type":"NodeParagraph","Properties":{"id":"20250206195641-p2ppcdd","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1 7"}]},{"ID":"20250206195641-y0c8wrk","Type":"NodeParagraph","Properties":{"id":"20250206195641-y0c8wrk","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1 4"}]},{"ID":"20250206195641-i1h9lu1","Type":"NodeParagraph","Properties":{"id":"20250206195641-i1h9lu1","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2 8"}]},{"ID":"20250206195641-t3oil4l","Type":"NodeParagraph","Properties":{"id":"20250206195641-t3oil4l","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2 5"}]},{"ID":"20250206195641-x5exm8l","Type":"NodeParagraph","Properties":{"id":"20250206195641-x5exm8l","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"4 3"}]},{"ID":"20250206195641-tfatv3l","Type":"NodeParagraph","Properties":{"id":"20250206195641-tfatv3l","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"3 9"}]},{"ID":"20250206195641-enr5t4m","Type":"NodeParagraph","Properties":{"id":"20250206195641-enr5t4m","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"4 6"}]},{"ID":"20250206195641-y9cdqn0","Type":"NodeParagraph","Properties":{"id":"20250206195641-y9cdqn0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-ygmakly","Type":"NodeParagraph","Properties":{"id":"20250206195641-ygmakly","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"4"}]},{"ID":"20250206195641-gl3nigt","Type":"NodeParagraph","Properties":{"id":"20250206195641-gl3nigt","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"​"},{"Type":"NodeImage","Children":[{"Type":"NodeBang","Data":"!"},{"Type":"NodeOpenBracket","Data":"["},{"Type":"NodeCloseBracket","Data":"]"},{"Type":"NodeOpenParen","Data":"("},{"Type":"NodeLinkDest","Data":"https://i-blog.csdnimg.cn/blog_migrate/29a0d93ff6782c402a6e3b973ef2d272.png"},{"Type":"NodeCloseParen","Data":")"}]},{"Type":"NodeText","Data":"​"}]},{"ID":"20250206195641-jlzvjlm","Type":"NodeParagraph","Properties":{"id":"20250206195641-jlzvjlm","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"每次算出他下面的size和n-size进行比较即可。"}]},{"ID":"20250206195641-varmi6l","Type":"NodeParagraph","Properties":{"id":"20250206195641-varmi6l","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"AC代码"}]},{"ID":"20250206195641-xa22hvo","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-xa22hvo","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include \u003ciostream\u003e\n#include \u003calgorithm\u003e\n#include \u003ccstring\u003e\n\nusing namespace std;\n\nconst int N = 1e5 + 10; //数据范围是10的5次方\nconst int M = 2 * N; //以有向图的格式存储无向图，所以每个节点至多对应2n-2条边\n\nint h[N]; //邻接表存储树，有n个节点，所以需要n个队列头节点\nint e[M]; //存储元素\nint ne[M]; //存储列表的next值\nint idx; //单链表指针\nint n; //题目所给的输入，n个节点\nint ans = N; //表示重心的所有的子树中，最大的子树的结点数目\n\nbool st[N]; //记录节点是否被访问过，访问过则标记为true\n\n//a所对应的单链表中插入b  a作为根 \nvoid add(int a, int b) {\n    e[idx] = b, ne[idx] = h[a], h[a] = idx++;\n}\n\n// dfs 框架\n/*\nvoid dfs(int u){\n    st[u]=true; // 标记一下，记录为已经被搜索过了，下面进行搜索过程\n    for(int i=h[u];i!=-1;i=ne[i]){\n        int j=e[i];\n        if(!st[j]) {\n            dfs(j);\n        }\n    }\n}\n*/\n\n//返回以u为根的子树中节点的个数，包括u节点\nint dfs(int u) {\n    int res = 0; //存储 删掉某个节点之后，最大的连通子图节点数\n    st[u] = true; //标记访问过u节点\n    int sum = 1; //存储 以u为根的树 的节点数, 包括u，如图中的4号节点\n\n    //访问u的每个子节点\n    for (int i = h[u]; i != -1; i = ne[i]) {\n        int j = e[i];\n        //因为每个节点的编号都是不一样的，所以 用编号为下标 来标记是否被访问过\n        if (!st[j]) {\n            int s = dfs(j);  // u节点的单棵子树节点数 如图中的size值\n            res = max(res, s); // 记录最大联通子图的节点数\n            sum += s; //以j为根的树 的节点数\n        }\n    }\n\n    //n-sum 如图中的n-size值，不包括根节点4；\n    res = max(res, n - sum); // 选择u节点为重心，最大的 连通子图节点数\n    ans = min(res, ans); //遍历过的假设重心中，最小的最大联通子图的 节点数\n    return sum;\n}\n\nint main() {\n    memset(h, -1, sizeof h); //初始化h数组 -1表示尾节点\n    cin \u003e\u003e n; //表示树的结点数\n\n    // 题目接下来会输入，n-1行数据，\n    // 树中是不存在环的，对于有n个节点的树，必定是n-1条边\n    for (int i = 0; i \u003c n - 1; i++) {\n        int a, b;\n        cin \u003e\u003e a \u003e\u003e b;\n        add(a, b), add(b, a); //无向图\n    }\n\n    dfs(1); //可以任意选定一个节点开始 u\u003c=n\n\n    cout \u003c\u003c ans \u003c\u003c endl;\n\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]},{"ID":"20250206195641-h6ac9a5","Type":"NodeHeading","HeadingLevel":3,"Properties":{"id":"20250206195641-h6ac9a5","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"### "},{"Type":"NodeText","Data":"3.4树的广度优先遍历"}]},{"ID":"20250206195641-k1lhyfy","Type":"NodeHeading","HeadingLevel":4,"Properties":{"id":"20250206195641-k1lhyfy","updated":"20250206195641"},"Children":[{"Type":"NodeHeadingC8hMarker","Data":"#### "},{"Type":"NodeText","Data":"3.4.1图中点的层次"}]},{"ID":"20250206195641-ilbmp4f","Type":"NodeParagraph","Properties":{"id":"20250206195641-ilbmp4f","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"给定一个 n个点 m条边的有向图，图中可能存在重边和自环。"}]},{"ID":"20250206195641-y2oxjxy","Type":"NodeParagraph","Properties":{"id":"20250206195641-y2oxjxy","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"所有边的长度都是 1，点的编号为 1∼n。"}]},{"ID":"20250206195641-9d44rrv","Type":"NodeParagraph","Properties":{"id":"20250206195641-9d44rrv","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"请你求出 1号点到 n号点的最短距离，如果从 1号点无法走到 n号点，输出 −1。"}]},{"ID":"20250206195641-ixyfcgn","Type":"NodeParagraph","Properties":{"id":"20250206195641-ixyfcgn","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入格式"}]},{"ID":"20250206195641-5ufm6cz","Type":"NodeParagraph","Properties":{"id":"20250206195641-5ufm6cz","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"第一行包含两个整数 n和 m。"}]},{"ID":"20250206195641-x05u02a","Type":"NodeParagraph","Properties":{"id":"20250206195641-x05u02a","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"接下来 m行，每行包含两个整数 a和 b，表示存在一条从 a走到 b的长度为 1 的边。"}]},{"ID":"20250206195641-x68zlf0","Type":"NodeParagraph","Properties":{"id":"20250206195641-x68zlf0","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出格式"}]},{"ID":"20250206195641-3mwervx","Type":"NodeParagraph","Properties":{"id":"20250206195641-3mwervx","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出一个整数，表示 1号点到 n号点的最短距离。"}]},{"ID":"20250206195641-b8x6uu4","Type":"NodeParagraph","Properties":{"id":"20250206195641-b8x6uu4","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"数据范围"}]},{"ID":"20250206195641-xox5f0y","Type":"NodeParagraph","Properties":{"id":"20250206195641-xox5f0y","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1≤n,m≤1e5"}]},{"ID":"20250206195641-p0bqssq","Type":"NodeParagraph","Properties":{"id":"20250206195641-p0bqssq","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输入样例："}]},{"ID":"20250206195641-hbhruxe","Type":"NodeParagraph","Properties":{"id":"20250206195641-hbhruxe","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"4 5"}]},{"ID":"20250206195641-bk9tg4p","Type":"NodeParagraph","Properties":{"id":"20250206195641-bk9tg4p","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1 2"}]},{"ID":"20250206195641-31gutw2","Type":"NodeParagraph","Properties":{"id":"20250206195641-31gutw2","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"2 3"}]},{"ID":"20250206195641-3yf51za","Type":"NodeParagraph","Properties":{"id":"20250206195641-3yf51za","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"3 4"}]},{"ID":"20250206195641-a0nyuc3","Type":"NodeParagraph","Properties":{"id":"20250206195641-a0nyuc3","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1 3"}]},{"ID":"20250206195641-77vknfe","Type":"NodeParagraph","Properties":{"id":"20250206195641-77vknfe","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1 4"}]},{"ID":"20250206195641-83xr99l","Type":"NodeParagraph","Properties":{"id":"20250206195641-83xr99l","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"输出样例："}]},{"ID":"20250206195641-814aczp","Type":"NodeParagraph","Properties":{"id":"20250206195641-814aczp","updated":"20250206195641"},"Children":[{"Type":"NodeText","Data":"1"}]},{"ID":"20250206195641-5ulaleq","Type":"NodeCodeBlock","IsFencedCodeBlock":true,"CodeBlockFenceChar":96,"CodeBlockFenceLen":3,"CodeBlockOpenFence":"YGBg","CodeBlockInfo":"Y3Bw","CodeBlockCloseFence":"YGBg","Properties":{"id":"20250206195641-5ulaleq","updated":"20250206195641"},"Children":[{"Type":"NodeCodeBlockFenceOpenMarker","Data":"```","CodeBlockFenceLen":3},{"Type":"NodeCodeBlockFenceInfoMarker","CodeBlockInfo":"Y3Bw"},{"Type":"NodeCodeBlockCode","Data":"#include\u003ciostream\u003e\n#include\u003calgorithm\u003e\n#include\u003ccstring\u003e\n#include\u003ccstdio\u003e\nusing namespace std;\nconst int N=1e6+10;\n\n//邻接表表示方法\nint h[N],e[N*2],ne[N*2],idx;\nint n,m;\nint d[N];//标记距离1号点的最短距离\nbool st[N];//标记访问标志\nint q[N];//定义一个队列\n\n//从a-\u003eb连接一条边\nvoid add(int a,int b)\n{\n    e[idx]=b,ne[idx]=h[a],h[a]=idx++;\n}\n\nint bfs()\n{\n    memset(d,-1,sizeof d);\n    int hh=0,tt=-1;\n    d[1]=0;\n    q[++tt]=1;//从1号点开始搜索\n    st[1]=true;\n    while(hh\u003c=tt)\n    {\n        int t=q[hh++];\n        for(int i=h[t];i!=-1;i=ne[i])//访问该点的邻接点\n        {\n            int j=e[i];\n            if(!st[j])\n            {\n                d[j]=d[t]+1;\n                q[++tt]=j;\n                st[j]=true;\n            }\n        }\n    }\n    return d[n];\n}\n\nint main()\n{\n    memset(h,-1,sizeof h);//初始化邻接表头\n    scanf(\"%d%d\",\u0026n,\u0026m);\n    while(m--)\n    {\n        int a,b;\n        scanf(\"%d%d\",\u0026a,\u0026b);\n        add(a,b);\n    }\n    printf(\"%d\\n\",bfs());\n    return 0;\n}\n"},{"Type":"NodeCodeBlockFenceCloseMarker","Data":"```","CodeBlockFenceLen":3}]}]}